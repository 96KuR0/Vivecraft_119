--- a/net/minecraft/client/Minecraft.java
+++ b/net/minecraft/client/Minecraft.java
@@ -7,20 +7,30 @@
 import com.mojang.authlib.minecraft.MinecraftSessionService;
 import com.mojang.authlib.properties.PropertyMap;
 import com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService;
+import com.mojang.blaze3d.platform.GLX;
+import com.mojang.blaze3d.platform.GlStateManager;
 import com.mojang.blaze3d.platform.PlatformDescriptors;
 import com.mojang.blaze3d.systems.RenderSystem;
 import com.mojang.datafixers.DataFixer;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
 import java.net.Proxy;
 import java.net.SocketAddress;
+import java.net.URL;
+import java.net.URLClassLoader;
 import java.nio.ByteOrder;
+import java.nio.FloatBuffer;
 import java.text.DecimalFormat;
 import java.text.DecimalFormatSymbols;
 import java.text.SimpleDateFormat;
+import java.util.ArrayDeque;
 import java.util.Collections;
 import java.util.Date;
+import java.util.Deque;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Locale;
 import java.util.Queue;
@@ -32,10 +42,48 @@
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
+
+import net.minecraft.state.EnumProperty;
+import net.minecraft.state.StateContainer;
+import net.minecraft.util.*;
+import net.minecraft.util.Timer;
+import net.optifine.Config;
+import net.optifine.CustomItems;
+import net.optifine.shaders.Shaders;
+import net.optifine.util.TextureUtils;
+import org.apache.commons.lang3.Validate;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.lwjgl.opengl.ARBShaderObjects;
+import org.lwjgl.opengl.GL11;
+import org.lwjgl.opengl.GL13;
+import org.lwjgl.opengl.GL30;
+import org.vivecraft.api.ErrorHelper;
+import org.vivecraft.control.VRInputAction;
+import org.vivecraft.gameplay.OpenVRPlayer;
+import org.vivecraft.gameplay.screenhandlers.GuiHandler;
+import org.vivecraft.gameplay.screenhandlers.KeyboardHandler;
+import org.vivecraft.gameplay.screenhandlers.RadialHandler;
+import org.vivecraft.gameplay.trackers.*;
+import org.vivecraft.gui.physical.PhysicalGuiManager;
+import org.vivecraft.provider.MCOpenVR;
+import org.vivecraft.provider.OpenVRStereoRenderer;
+import org.vivecraft.render.MenuWorldRenderer;
+import org.vivecraft.render.PlayerModelController;
+import org.vivecraft.render.RenderConfigException;
+import org.vivecraft.render.VRShaders;
+import org.vivecraft.render.RenderPass;
+import org.vivecraft.settings.VRHotkeys;
+import org.vivecraft.settings.VRSettings;
+import org.vivecraft.settings.VRSettings.VrOptions;
+import org.vivecraft.utils.*;
+import org.vivecraft.utils.lwjgl.Matrix4f;
+
 import net.minecraft.block.Block;
 import net.minecraft.block.BlockRenderType;
 import net.minecraft.block.BlockState;
 import net.minecraft.client.audio.MusicTicker;
+import net.minecraft.client.audio.SoundEngine;
 import net.minecraft.client.audio.SoundHandler;
 import net.minecraft.client.entity.player.ClientPlayerEntity;
 import net.minecraft.client.gui.FontRenderer;
@@ -74,6 +122,7 @@
 import net.minecraft.client.renderer.BufferBuilder;
 import net.minecraft.client.renderer.FirstPersonRenderer;
 import net.minecraft.client.renderer.FogRenderer;
+import net.minecraft.client.renderer.GLAllocation;
 import net.minecraft.client.renderer.GameRenderer;
 import net.minecraft.client.renderer.IWindowEventListener;
 import net.minecraft.client.renderer.ItemRenderer;
@@ -185,6 +234,7 @@
 import net.minecraft.util.math.EntityRayTraceResult;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.util.math.RayTraceResult;
+import net.minecraft.util.math.Vec3d;
 import net.minecraft.util.registry.Bootstrap;
 import net.minecraft.util.registry.Registry;
 import net.minecraft.util.text.ITextComponent;
@@ -208,6 +258,80 @@
 public class Minecraft extends RecursiveEventLoop<Runnable> implements ISnooperInfo, IWindowEventListener
 {
     private static Minecraft instance;
+	// VIVE START - teleport movement
+	public OpenVRPlayer vrPlayer;
+	public BackpackTracker backpackTracker = new BackpackTracker(this);
+	public BowTracker bowTracker = new BowTracker(this);
+	public SwimTracker swimTracker = new SwimTracker(this);
+	public EatingTracker autoFood = new EatingTracker(this);
+	public JumpTracker jumpTracker = new JumpTracker(this);
+	public SneakTracker sneakTracker = new SneakTracker(this);
+	public ClimbTracker climbTracker = new ClimbTracker(this);
+	public RunTracker runTracker = new RunTracker(this);
+	public RowTracker rowTracker = new RowTracker(this);
+	public TeleportTracker teleportTracker = new TeleportTracker(this);
+	public SwingTracker swingTracker = new SwingTracker(this);
+	public HorseTracker horseTracker = new HorseTracker(this);
+	public VehicleTracker vehicleTracker = new VehicleTracker(this);
+	public PhysicalGuiManager physicalGuiManager = new PhysicalGuiManager(this);
+	public InteractTracker interactTracker = new InteractTracker(this);
+
+	public ThreadGroup backgroundThreadGroup = new ThreadGroup("background");
+	// VIVE END - teleport movement
+
+	/** MINECRIFT */
+
+	public boolean minecriftDebug = false;
+	public final float PIOVER180 = (float) (Math.PI / 180);
+
+	public int lastShaderIndex = -1;
+	public Field fieldHwnd = null;
+	public Field fieldDisplay = null;
+	public Field fieldWindow = null;
+	public Field fieldResized = null;
+	public Method fieldResizedMethod = null;
+	public OpenVRStereoRenderer stereoProvider;
+	public VRSettings vrSettings;
+	public long lastIntegratedServerLaunchCheck = 0;
+	public boolean integratedServerLaunchInProgress = false;
+
+	public boolean grabScreenShot = false;
+	public boolean lastShowMouseNative = true;
+	public boolean enableWorldExport = false;
+	public SoundEngine sndManager = null;
+	public MenuWorldRenderer menuWorldRenderer;
+
+	private FloatBuffer matrixBuffer = GLAllocation.createDirectFloatBuffer(16);
+	private FloatBuffer matrixBuffer2 = GLAllocation.createDirectFloatBuffer(16);
+
+	private boolean firstInit = true;
+	public boolean showSplashScreen = true;
+	public long splashTimer1 = 0;
+	public long splashTimer2 = 0;
+	private Framebuffer splash;
+	private float splashFadeAlpha = 0;
+	public Deque<Long> runTickTimeNanos = new ArrayDeque<Long>();
+	public long medianRunTickTimeNanos = 0;
+	public long frameIndex = 0;
+	public ErrorHelper errorHelper;
+	public RenderPass currentPass;
+	private boolean lastClick;
+	public boolean resourcePacksChanged;
+
+	public int hmdAvgLength = 90;
+	public LinkedList<Vec3d> hmdPosSamples = new LinkedList<Vec3d>();
+	public LinkedList<Float> hmdYawSamples = new LinkedList<Float>();
+	private float hmdYawTotal;
+	private float hmdYawLast;
+	public int tickCounter;
+	private boolean trigger;
+	/*
+	 * The minecriftVerString will be automatically updated by the build scripts, do
+	 * not modify here. Modify minecriftversion.py in root minecrift dir.
+	 */
+    public final String minecriftVerString = "Vivecraft 1.15.2 jrbudda-1-a0";
+	/* end version */
+	/** END MINECRIFT */
     private static final Logger LOGGER = LogManager.getLogger();
     public static final boolean IS_RUNNING_ON_MAC = Util.getOSType() == Util.OS.OSX;
     public static final ResourceLocation DEFAULT_FONT_RENDERER_NAME = new ResourceLocation("default");
@@ -218,7 +342,9 @@
     private final TextureManager textureManager;
     private final DataFixer dataFixer;
     private final VirtualScreen virtualScreen;
-    private final MainWindow mainWindow;
+    //Vivecraft Public
+    public final MainWindow mainWindow;
+    //
     private final Timer timer = new Timer(20.0F, 0L);
     private final Snooper snooper = new Snooper("client", this, Util.milliTime());
     private final RenderTypeBuffers renderTypeBuffers;
@@ -360,6 +486,14 @@
         this.dataFixer = DataFixesManager.getDataFixer();
         this.toastGui = new ToastGui(this);
         this.tutorial = new Tutorial(this);
+        		/** MINECRIFT **/
+		VRSettings.initSettings(this, gameDir);
+		if (!vrSettings.badStereoProviderPluginID.isEmpty()) {
+			vrSettings.stereoProviderPluginID = vrSettings.badStereoProviderPluginID;
+			vrSettings.badStereoProviderPluginID = "";
+			vrSettings.saveOptions();
+		}
+		/** END MINECRIFT **/
         this.thread = Thread.currentThread();
         this.gameSettings = new GameSettings(this, this.gameDir);
         this.creativeSettings = new CreativeSettings(this.gameDir, this.dataFixer);
@@ -426,6 +560,14 @@
         {
             this.fontRenderer = fontrenderer;
             this.fontRenderer.setBidiFlag(this.languageManager.isCurrentLanguageBidirectional());
+			/** MINECRIFT */
+			try {
+				initMinecrift();
+			} catch (Exception e) {
+				// TODO Auto-generated catch block
+				e.printStackTrace();
+			}
+			/** END MINECRIFT */
             this.resourceManager.addReloadListener(new GrassColorReloadListener());
             this.resourceManager.addReloadListener(new FoliageColorReloadListener());
             this.mainWindow.setRenderPhase("Startup");
@@ -478,10 +620,22 @@
                 this.displayGuiScreen(new MainMenuScreen(true));
             }
 
+		menuWorldRenderer = new MenuWorldRenderer();
+		// VIVE
+		// this.renderGlobal.makeEntityOutlineShader();
+		vrSettings.firstRun = false;
+		vrSettings.saveOptions();
+		// END VIVE
             ResourceLoadProgressGui.loadLogoTexture(this);
             List<IResourcePack> list = this.resourcePackRepository.getEnabledPacks().stream().map(ResourcePackInfo::getResourcePack).collect(Collectors.toList());
             this.setLoadingGui(new ResourceLoadProgressGui(this, this.resourceManager.reloadResources(Util.getServerExecutor(), this, RESOURCE_RELOAD_INIT_TASK, list), (p_229990_2_) ->
             {
+        		// Vivecraft - post load
+        		if (stereoProvider.isInitialized())
+        			menuWorldRenderer.init();
+        		LangHelper.loadLocaleData();
+        		MCOpenVR.initInputAndApplication();
+        		//
                 Util.acceptOrElse(p_229990_2_, this::restoreResourcePacks, () -> {
                     this.languageManager.parseLanguageMetadata(list);
 
@@ -494,20 +648,23 @@
         }
     }
 
+    //updatewindowtitle
     public void func_230150_b_()
     {
         this.mainWindow.func_230148_b_(this.func_230149_ax_());
     }
 
+    //getwindowtitle
     private String func_230149_ax_()
     {
-        StringBuilder stringbuilder = new StringBuilder("Minecraft");
-
-        if (this.func_230151_c_())
-        {
-            stringbuilder.append("*");
-        }
-
+    	//Vivecraft
+        StringBuilder stringbuilder = new StringBuilder(minecriftVerString);
+//
+//        if (this.func_230151_c_())
+//        {
+//            stringbuilder.append("*");
+//        }
+//
         stringbuilder.append(" ");
         stringbuilder.append(SharedConstants.getVersion().getName());
         ClientPlayNetHandler clientplaynethandler = this.getConnection();
@@ -537,6 +694,7 @@
         return stringbuilder.toString();
     }
 
+    //is modded
     public boolean func_230151_c_()
     {
         return !"vanilla".equals(ClientBrandRetriever.getClientModName()) || Minecraft.class.getSigners() == null;
@@ -790,6 +948,13 @@
                 List<IResourcePack> list = this.resourcePackRepository.getEnabledPacks().stream().map(ResourcePackInfo::getResourcePack).collect(Collectors.toList());
                 this.setLoadingGui(new ResourceLoadProgressGui(this, this.resourceManager.reloadResources(Util.getServerExecutor(), this, RESOURCE_RELOAD_INIT_TASK, list), (p_229992_3_) ->
                 {
+                	//VIVECRAFT
+        			if (menuWorldRenderer.isReady() && resourcePacksChanged) {
+						menuWorldRenderer.destroy();
+						menuWorldRenderer.prepare();
+					}
+					resourcePacksChanged = false;
+					//
                     Util.acceptOrElse(p_229992_3_, this::restoreResourcePacks, () -> {
                         this.languageManager.parseLanguageMetadata(list);
                         this.worldRenderer.loadRenderers();
@@ -901,6 +1066,10 @@
             this.ingameGUI.getChatGUI().clearChatMessages(true);
         }
 
+		// VIVECRAFT
+		GuiHandler.onScreenChanged(this.currentScreen, guiScreenIn, true);
+		// VIVECRAFT
+
         this.currentScreen = guiScreenIn;
 
         if (guiScreenIn != null)
@@ -964,6 +1133,12 @@
         finally
         {
             Util.nanoTimeSupplier = System::nanoTime;
+			// Vivecraft
+			try {
+				MCOpenVR.destroy();
+			} catch (Exception e) {
+			}
+			//
 
             if (this.crashReporter == null)
             {
@@ -1036,22 +1211,153 @@
             this.profiler.endSection();
         }
 
+		{// Vivecraft
+			this.frameDelta = (i - this.prevFrameTime) / 1000000000F;
+			this.prevFrameTime = i;
+			// avoid having to change GLX
+			gameSettings.ofUseFbo = true;
+			gameSettings.ofUseVbo = true;
+			gameSettings.ofFastRender = false;
+			// GLX.framebufferSupported = true;
+		}
+		/** MINECRIFT */ // setup the display, render buffers, shaders etc.
+		this.frameIndex++;
+
+		try {
+			stereoProvider.setupRenderConfiguration();
+		} catch (RenderConfigException e) {
+			this.currentScreen = null;
+			if (loadingGui != null) {
+				loadingGui.render(0, 0, 0);
+			} else {
+				GLX.glBindFramebuffer(GLX.GL_FRAMEBUFFER, 0);
+				GL11.glViewport(0, 0, this.mainWindow.getWidth(), this.mainWindow.getHeight());
+				GlStateManager.clearColor(0, 0, 0, 1);
+				GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+				gameRenderer.displayNotificationText("Render Setup Failed " , e.error,  "",
+						this.mainWindow.getWidth(), this.mainWindow.getHeight(), false, true);
+				this.mainWindow.update(false);
+				if (this.frameIndex % 300 == 0)
+					System.out.println(e.title + " " + e.error);
+				try {
+					Thread.sleep(10);
+				} catch (InterruptedException e1) {
+				}
+			}
+			return;
+		} catch (Exception e) {
+			e.printStackTrace();
+		}
+		/** END MINECRIFT */
+
+		// VIVECRAFT
+		this.profiler.startSection("Poll");
+		// Poll sensors
+		MCOpenVR.poll(frameIndex);
+		this.profiler.endSection();
+
+		vrPlayer.postPoll();
         this.profiler.startSection("tick");
 
         if (renderWorldIn)
         {
             for (int j = 0; j < Math.min(10, this.timer.elapsedTicks); ++j)
             {
+				// VIVECRAFT
+				vrPlayer.preTick();
+				//
                 this.runTick();
+				// VIVECRAFT
+				vrPlayer.postTick();
+				//
             }
         }
 
+		this.profiler.endStartSection("setupRenderConfiguration");
         this.mouseHelper.updatePlayerLook();
         this.mainWindow.setRenderPhase("Render");
+		// VIVECRAFT - Check again in case something changed during Tick.
+		try {
+			checkGLError("pre render setup ");
+			stereoProvider.setupRenderConfiguration();
+			checkGLError("post render setup ");
+		} catch (Exception e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+		//
+		// Vivecraft
+		float par1 = this.isGamePaused ? this.renderPartialTicksPaused : this.timer.renderPartialTicks;
+
+		this.profiler.endStartSection("preRender");
+		vrPlayer.preRender(par1);
+        this.profiler.endSection();
+
+		this.profiler.startSection("Gui");
+
+		GlStateManager.depthMask(true);
+		GlStateManager.colorMask(true, true, true, true);
+
+		// Render GUI to FBO if necessary
+		this.framebuffer = GuiHandler.guiFramebuffer; // draw to 2d gui.
+        this.framebuffer.bindFramebuffer(true);
+
+		this.gameRenderer.drawFramebuffer(par1, i1, renderWorldIn); // VIVE - added param for debug info
+
+		if (KeyboardHandler.Showing && !this.vrSettings.physicalKeyboard) {
+			this.framebuffer = KeyboardHandler.Framebuffer;
+			this.framebuffer.bindFramebuffer(true);
+			this.gameRenderer.drawScreen(par1, KeyboardHandler.UI);
+		}
+
+		if (RadialHandler.isShowing()) {
+			this.framebuffer = RadialHandler.Framebuffer;
+			this.framebuffer.bindFramebuffer(true);
+			this.gameRenderer.drawScreen(par1, RadialHandler.UI);
+		}
+
+		checkGLError("post 2d ");
+		VRHotkeys.updateMovingThirdPersonCam();
+		//
         this.profiler.endStartSection("sound");
-        this.soundHandler.updateListener(this.gameRenderer.getActiveRenderInfo());
+		// Vivecraft
+		updateSoundListener();
+		// this.soundHandler.setListener(this.player, this.timer.renderPartialTicks);
         this.profiler.endSection();
+		this.profiler.startSection("hmdSampling");
+		if (hmdPosSamples.size() == hmdAvgLength)
+			hmdPosSamples.removeFirst();
+		if (hmdYawSamples.size() == hmdAvgLength)
+			hmdYawSamples.removeFirst();
+
+		float yaw = vrPlayer.vrdata_room_pre.hmd.getYaw();
+		if (yaw < 0)
+			yaw += 360;
+		hmdYawTotal += angleDiff(yaw, hmdYawLast);
+		hmdYawLast = yaw;
+		if (Math.abs(angleNormalize(hmdYawTotal) - hmdYawLast) > 1 || hmdYawTotal > 100000) {
+			hmdYawTotal = hmdYawLast;
+			System.out.println("HMD yaw desync/overflow corrected");
+		}
+		hmdPosSamples.add(vrPlayer.vrdata_room_pre.hmd.getPosition());
+		float yawAvg = 0;
+		if (hmdYawSamples.size() > 0) {
+			for (float f : hmdYawSamples) {
+				yawAvg += f;
+			}
+			yawAvg /= hmdYawSamples.size();
+		}
+		if (Math.abs((hmdYawTotal - yawAvg)) > 20)
+			trigger = true;
+		if (Math.abs((hmdYawTotal - yawAvg)) < 1)
+			trigger = false;
+		if (trigger || hmdYawSamples.isEmpty())
+			hmdYawSamples.add(hmdYawTotal);
+		this.profiler.endSection(); // hmdsampling
+		//
+
         this.profiler.startSection("render");
+/* Vivecraft
         RenderSystem.pushMatrix();
         RenderSystem.clear(16640, IS_RUNNING_ON_MAC);
         this.framebuffer.bindFramebuffer(true);
@@ -1059,47 +1365,107 @@
         this.profiler.startSection("display");
         RenderSystem.enableTexture();
         this.profiler.endSection();
-
+*/
         if (!this.skipRenderWorld)
         {
             this.profiler.endStartSection("gameRenderer");
-            this.gameRenderer.updateCameraAndRender(this.isGamePaused ? this.renderPartialTicksPaused : this.timer.renderPartialTicks, i, renderWorldIn);
-            this.profiler.endStartSection("toasts");
-            this.toastGui.render();
-            this.profiler.endSection();
-        }
-
-        this.profiler.endTick();
 
-        if (this.gameSettings.showDebugInfo && this.gameSettings.showDebugProfilerChart && !this.gameSettings.hideGUI)
-        {
-            this.profiler.getFixedProfiler().enable();
-            this.drawProfiler();
-        }
-        else
-        {
-            this.profiler.getFixedProfiler().disable();
-        }
+			// VIVECRAFT RENDERING MAIN
+			if (minecriftDebug)
+				print("FrameIndex: " + frameIndex);
+
+			boolean shouldupdate = true;
+
+			List<RenderPass> passes = this.stereoProvider.getRenderPasses();
+
+			/** Minecrift - main stereo render loop **/
+			for (RenderPass pass : passes) {
+				this.currentPass = pass;
+				switch (pass) {
+				case LEFT:
+				case RIGHT:
+					this.framebuffer = stereoProvider.framebufferVrRender;
+					break;
+				case CENTER:
+					this.framebuffer = stereoProvider.framebufferUndistorted;
+					break;
+				case THIRD:
+					this.framebuffer = stereoProvider.framebufferMR;
+					break;
+				}
+
+				this.profiler.startSection("Eye:" + currentPass.ordinal());
+				this.profiler.startSection("setup");
+				this.framebuffer.bindFramebuffer(true); // draw to main texture for every pass
+            this.profiler.endSection();
+				shouldupdate = renderSingleView(pass.ordinal(), par1, renderWorldIn);
+				this.profiler.endSection(); // eye
 
-        this.framebuffer.unbindFramebuffer();
-        RenderSystem.popMatrix();
-        RenderSystem.pushMatrix();
-        this.framebuffer.framebufferRender(this.mainWindow.getFramebufferWidth(), this.mainWindow.getFramebufferHeight());
-        RenderSystem.popMatrix();
-        this.profiler.startTick();
-        this.profiler.startSection("updateDisplay");
-        this.mainWindow.flipFrame();
-        int l = this.getFramerateLimit();
+				if (grabScreenShot) {
+					boolean inPass;
+					if (passes.contains(RenderPass.CENTER)) {
+						inPass = (pass == RenderPass.CENTER);
+					} else {
+						inPass = (pass == RenderPass.LEFT);
+        }
+
+					if (inPass) {
+						this.framebuffer.unbindFramebuffer();
+						// GLX.fbo = false; // huh?
+						ScreenShotHelper.saveScreenshot(this.gameDir, this.framebuffer.framebufferWidth,
+								this.framebuffer.framebufferHeight, this.framebuffer, (text) -> {
+									// this.addScheduledTask(() -> {
+									// this.ingameGUI.getChatGUI().printChatMessage(text);
+									// });
+								});
+						// GLX.fbo = true; // what is this?
+						grabScreenShot = false;
+					}
+				}
+			} // end per eye rendering.
+
+			// VIVECRAFT
+			vrPlayer.postRender(par1);
+			//
+
+			if (this.vrSettings.displayMirrorMode == VRSettings.MIRROR_OFF && MCOpenVR.isHMDTracking()) {
+				GlStateManager.viewport(0, 0, this.mainWindow.getWidth(), this.mainWindow.getHeight());
+				shouldupdate = true;
+				this.framebuffer.unbindFramebuffer(); // draw directly to window
+				GlStateManager.clearColor(0, 0, 0, 1);
+				GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT);
+				gameRenderer.displayNotificationText("Mirror is OFF", "", "", this.mainWindow.getWidth(),
+						this.mainWindow.getHeight(), false, true);
+				// this.framebuffer.bindFramebuffer(true);
+        }
+
+			profiler.startSection("Display/Reproject");
+			try {
+				this.stereoProvider.endFrame();
+			} catch (Exception e) {
+				LOGGER.error(e.toString());
+        }
+			profiler.endSection();
+
+			profiler.endSection(); // gamerenderer
+			checkGLError("post submit ");
+
+			//// END MAIN VIVECRAFT RENDERING
+		}
+
+		/*
+		 * /Vivecraft this.framebuffer.unbindFramebuffer(); GlStateManager.popMatrix();
+		 * GlStateManager.pushMatrix();
+		 * this.framebuffer.framebufferRender(this.mainWindow.getFramebufferWidth(),
+		 * this.mainWindow.getFramebufferHeight()); GlStateManager.popMatrix();
+		 * GlStateManager.pushMatrix();
+		 * this.entityRenderer.renderStreamIndicator(this.timer.renderPartialTicks);
+		 * GlStateManager.popMatrix(); this.mainWindow.update(true); Thread.yield();
+		 * this.mainWindow.setRenderPhase("Post render");
+		 */
 
-        if ((double)l < AbstractOption.FRAMERATE_LIMIT.getMaxValue())
-        {
-            RenderSystem.limitDisplayFPS(l);
-        }
+		this.mainWindow.update(false); // no fps limit
 
-        this.profiler.endStartSection("yield");
-        Thread.yield();
-        this.profiler.endSection();
-        this.mainWindow.setRenderPhase("Post render");
         ++this.fpsCounter;
         boolean flag = this.isSingleplayer() && (this.currentScreen != null && this.currentScreen.isPauseScreen() || this.loadingGui != null && this.loadingGui.isPauseScreen()) && !this.integratedServer.getPublic();
 
@@ -1136,6 +1502,12 @@
         }
 
         this.profiler.endTick();
+
+		if (this.gameSettings.showDebugProfilerChart && !this.gameSettings.hideGUI) {
+			this.profiler.func_219899_d().func_219939_d();
+		} else {
+			this.profiler.func_219899_d().func_219938_b();
+		}
     }
 
     public void updateWindowSize()
@@ -1148,9 +1520,23 @@
             this.currentScreen.resize(this, this.mainWindow.getScaledWidth(), this.mainWindow.getScaledHeight());
         }
 
+		if (stereoProvider != null)
+			stereoProvider.reinitFrameBuffers("Main Window Changed");
+
         Framebuffer framebuffer = this.getFramebuffer();
-        framebuffer.resize(this.mainWindow.getFramebufferWidth(), this.mainWindow.getFramebufferHeight(), IS_RUNNING_ON_MAC);
-        this.gameRenderer.updateShaderGroupSize(this.mainWindow.getFramebufferWidth(), this.mainWindow.getFramebufferHeight());
+
+		if (framebuffer != null) {
+			// Vivecraft no
+			// framebuffer.func_216491_a(this.mainWindow.getFramebufferWidth(),
+			// this.mainWindow.getFramebufferHeight(), IS_RUNNING_ON_MAC);
+        }
+
+		if (this.gameRenderer != null && this.stereoProvider.framebufferVrRender != null) {
+			this.gameRenderer.updateShaderGroupSize(this.stereoProvider.framebufferVrRender.framebufferTextureWidth,
+					this.stereoProvider.framebufferVrRender.framebufferTextureHeight);
+        }
+
+      //  this.gameRenderer.updateShaderGroupSize(this.mainWindow.getFramebufferWidth(), this.mainWindow.getFramebufferHeight());
         this.mouseHelper.setIgnoreFirstMove();
     }
 
@@ -1228,7 +1614,7 @@
         }
     }
 
-    private void drawProfiler()
+    public void drawProfiler()
     {
         if (this.profiler.getFixedProfiler().isEnabled())
         {
@@ -1395,12 +1781,13 @@
                     if (this.playerController.onPlayerDamageBlock(blockpos, direction))
                     {
                         this.particles.addBlockHitEffects(blockpos, direction);
+                        //Vivecraft
+                    	getFirstPersonRenderer().swingType = VRFirstPersonArmSwing.Attack;
+                    	//
                         this.player.swingArm(Hand.MAIN_HAND);
                     }
                 }
-            }
-            else
-            {
+			} else if (vrSettings.seated) {
                 this.playerController.resetBlockRemoving();
             }
         }
@@ -1442,10 +1829,11 @@
                         {
                             this.leftClickCounter = 10;
                         }
-
                         this.player.resetCooldown();
                 }
-
+                //Vivecraft
+            	getFirstPersonRenderer().swingType = VRFirstPersonArmSwing.Attack;
+            	//
                 this.player.swingArm(Hand.MAIN_HAND);
             }
         }
@@ -1453,9 +1841,8 @@
 
     private void rightClickMouse()
     {
-        if (!this.playerController.getIsHittingBlock())
-        {
-            this.rightClickDelayTimer = 4;
+		if (!this.playerController.getIsHittingBlock() || vrSettings.seated == false) {
+			this.rightClickDelayTimer = vrSettings.seated ? 4 : vrSettings.rightclickDelay; 
 
             if (!this.player.isRowingBoat())
             {
@@ -1473,6 +1860,7 @@
                         switch (this.objectMouseOver.getType())
                         {
                             case ENTITY:
+							physicalGuiManager.preClickAction();
                                 EntityRayTraceResult entityraytraceresult = (EntityRayTraceResult)this.objectMouseOver;
                                 Entity entity = entityraytraceresult.getEntity();
                                 ActionResultType actionresulttype = this.playerController.interactWithEntity(this.player, entity, entityraytraceresult, hand);
@@ -1548,6 +1936,7 @@
 
     public void runTick()
     {
+    			this.tickCounter++;
         if (this.rightClickDelayTimer > 0)
         {
             --this.rightClickDelayTimer;
@@ -1561,7 +1950,7 @@
         }
 
         this.profiler.endSection();
-        this.gameRenderer.getMouseOver(1.0F);
+        //this.gameRenderer.getMouseOver(1.0F);
         this.tutorial.onMouseHover(this.world, this.objectMouseOver);
         this.profiler.startSection("gameMode");
 
@@ -1572,10 +1961,11 @@
 
         this.profiler.endStartSection("textures");
 
-        if (this.world != null)
-        {
+		// Vivecraft tick the main menu too
+		// if (this.world != null)
+		// {
             this.textureManager.tick();
-        }
+		// }
 
         if (this.currentScreen == null && this.player != null)
         {
@@ -1593,6 +1983,7 @@
             this.displayGuiScreen((Screen)null);
         }
 
+
         if (this.currentScreen != null)
         {
             this.leftClickCounter = 10000;
@@ -1610,6 +2001,11 @@
         {
             this.ingameGUI.reset();
         }
+		// Vivecraft
+		this.profiler.endStartSection("vrProcessInputs");
+		MCOpenVR.processInputs();
+		MCOpenVR.processBindings();
+		///
 
         if (this.loadingGui == null && (this.currentScreen == null || this.currentScreen.passEvents))
         {
@@ -1622,8 +2018,27 @@
             }
         }
 
-        if (this.world != null)
-        {
+		// Vivecraft
+		this.profiler.endStartSection("vrInputActionsTick");
+		for (VRInputAction action : MCOpenVR.getInputActions()) {
+			action.tick();
+		}
+
+		if (vrSettings.displayMirrorMode == VRSettings.MIRROR_MIXED_REALITY
+				|| vrSettings.displayMirrorMode == VRSettings.MIRROR_THIRD_PERSON)
+			VRHotkeys.handleMRKeys();
+
+		if (this.world != null) {
+			if (this.player != null) {
+				// Vivecraft
+				this.vrPlayer.updateFreeMove();
+				if (this.vrPlayer.teleportWarningTimer >= 0) {
+					if (--this.vrPlayer.teleportWarningTimer == 0) {
+						printChatMessage(
+								"This server does not support teleporting. Restricted movement mode (fallback to free move) has been enabled.");
+					}
+				}
+			}
             this.profiler.endStartSection("gameRenderer");
 
             if (!this.isGamePaused)
@@ -1655,8 +2070,13 @@
             this.gameRenderer.stopUseShader();
         }
 
-        if (!this.isGamePaused)
-        {
+		// Vivecraft
+		if (this.menuWorldRenderer != null)
+			this.menuWorldRenderer.tick();
+		PlayerModelController.getInstance().tick();
+		//
+
+		if (!this.isGamePaused) {
             this.musicTicker.tick();
         }
 
@@ -1719,25 +2139,28 @@
         this.profiler.endSection();
     }
 
-    private void processKeyBinds()
-    {
-        for (; this.gameSettings.keyBindTogglePerspective.isPressed(); this.worldRenderer.setDisplayListEntitiesDirty())
-        {
-            ++this.gameSettings.thirdPersonView;
-
-            if (this.gameSettings.thirdPersonView > 2)
-            {
-                this.gameSettings.thirdPersonView = 0;
-            }
-
-            if (this.gameSettings.thirdPersonView == 0)
-            {
-                this.gameRenderer.loadEntityShader(this.getRenderViewEntity());
-            }
-            else if (this.gameSettings.thirdPersonView == 1)
-            {
-                this.gameRenderer.loadEntityShader((Entity)null);
-            }
+	private void processKeyBinds() {
+		for (; this.gameSettings.keyBindTogglePerspective.isPressed(); this.worldRenderer
+				.setDisplayListEntitiesDirty()) {
+			vrSettings.setOptionValue(VrOptions.MIRROR_DISPLAY);
+			this.ingameGUI.getChatGUI().printChatMessage(
+					new StringTextComponent(vrSettings.getButtonDisplayString(VrOptions.MIRROR_DISPLAY)));
+
+			// VIVECRAFT: Credits debug
+			// this.displayScreen(new GuiWinGame(true,
+			// com.google.common.util.concurrent.Runnables.doNothing()));
+
+			/*
+			 * Vivecraft override F5 ++this.gameSettings.thirdPersonView;
+			 * 
+			 * if (this.gameSettings.thirdPersonView > 2) {
+			 * this.gameSettings.thirdPersonView = 0; }
+			 * 
+			 * if (this.gameSettings.thirdPersonView == 0) {
+			 * this.gameRenderer.loadEntityShader(this.getRenderViewEntity()); } else if
+			 * (this.gameSettings.thirdPersonView == 1) {
+			 * this.gameRenderer.loadEntityShader((Entity)null); }
+			 */
         }
 
         while (this.gameSettings.keyBindSmoothCamera.isPressed())
@@ -1805,7 +2228,7 @@
 
         if (flag2)
         {
-            while (this.gameSettings.keyBindChat.isPressed())
+   			if (this.currentScreen == null && this.gameSettings.keyBindChat.isPressed())
             {
                 this.displayGuiScreen(new ChatScreen(""));
             }
@@ -1816,10 +2239,10 @@
             }
         }
 
-        if (this.player.isHandActive())
-        {
-            if (!this.gameSettings.keyBindUseItem.isKeyDown())
-            {
+		if (this.player.isHandActive()) {
+			if (!this.gameSettings.keyBindUseItem.isKeyDown()
+					&& (bowTracker.isActive(player) == false || vrSettings.seated)) {
+				if (!autoFood.isEating())
                 this.playerController.onStoppedUsingItem(this.player);
             }
 
@@ -1840,10 +2263,18 @@
         }
         else
         {
-            while (this.gameSettings.keyBindAttack.isPressed())
-            {
+			// VIVE SUPPORT HAND SWINGING
+			if (this.gameSettings.keyBindAttack.isPressed() && currentScreen == null) {
                 this.clickMouse();
-            }
+				lastClick = true;
+			} else if (!this.gameSettings.keyBindAttack.isKeyDown()) {
+				this.leftClickCounter = 0;
+				if (lastClick) {
+					this.playerController.resetBlockRemoving();
+            }
+				lastClick = false;
+			}
+			/// END VIVE
 
             while (this.gameSettings.keyBindUseItem.isPressed())
             {
@@ -1861,7 +2292,7 @@
             this.rightClickMouse();
         }
 
-        this.sendClickBlockToController(this.currentScreen == null && this.gameSettings.keyBindAttack.isKeyDown() && this.mouseHelper.isMouseGrabbed());
+		this.sendClickBlockToController(this.currentScreen == null && this.gameSettings.keyBindAttack.isKeyDown());
     }
 
     public void launchIntegratedServer(String folderName, String worldName, @Nullable WorldSettings worldSettingsIn)
@@ -1952,6 +2383,9 @@
 
     public void loadWorld(ClientWorld worldClientIn)
     {
+		// VIVE START - reset room origin
+		vrPlayer.setRoomOrigin(0, 0, 0, true);
+		// VIVE END - reset room origin
         WorkingScreen workingscreen = new WorkingScreen();
         workingscreen.displaySavingString(new TranslationTextComponent("connect.joining"));
         this.updateScreenTick(workingscreen);
@@ -2223,6 +2657,8 @@
                 }
             }
         }
+
+		physicalGuiManager.init(player);
     }
 
     private ItemStack storeTEInStack(ItemStack stack, TileEntity te)
@@ -2740,4 +3176,630 @@
     {
         this.modelManager.setMaxMipmapLevel(p_228020_1_);
     }
+
+	// VIVECRAFT ADDITIONS
+	// **************************************************************************
+
+	public void printChatMessage(String msg) {
+		if (this.world != null) {
+			ITextComponent chatText = new StringTextComponent(msg);
+			this.ingameGUI.getChatGUI().printChatMessage(chatText);
+		}
+	}
+
+	public Matrix4f getMRTransform() {
+		// I swear to god this should be correct for column-major and
+		// post-multiplication for view matrix
+
+		Vec3d roomo = vrPlayer.vrdata_world_render.origin;
+
+		FloatBuffer conrot = null;
+
+		Object temp;
+		if (MCOpenVR.mrMovingCamActive) {
+			org.vivecraft.utils.Matrix4f temp2 = MCOpenVR.getAimRotation(2);
+			conrot = temp2.inverted().toFloatBuffer();
+		} else {
+			// reconstruct from vrsettings
+			Matrix4f m = vrSettings.vrFixedCamrotQuat.getMatrix();
+
+			// m=m.rotate((float) Math.toRadians(-vrSettings.vrFixedCamrotYaw), new
+			// org.vivecraft.utils.lwjgl.Vector3f(0, 1, 0));
+			// m=m.rotate((float) Math.toRadians(-vrSettings.vrFixedCamrotPitch), new
+			// org.vivecraft.utils.lwjgl.Vector3f(1, 0, 0));
+			// m=m.rotate((float) Math.toRadians(vrSettings.vrFixedCamrotRoll), new
+			// org.vivecraft.utils.lwjgl.Vector3f(0, 0, 1));
+			// idk why this one was here
+			// m=m.rotate((float) Math.toRadians(180), new
+			// org.vivecraft.utils.lwjgl.Vector3f(0, 1, 0));
+
+			matrixBuffer2.rewind();
+			m.store(matrixBuffer2);
+			matrixBuffer2.rewind();
+			conrot = matrixBuffer2;
+
+		}
+
+		GlStateManager.matrixMode(GL11.GL_MODELVIEW);
+		GlStateManager.pushMatrix();
+		GlStateManager.loadIdentity();
+
+		// Room pose
+		GlStateManager.translated(-roomo.x, -roomo.y, -roomo.z);
+		GlStateManager.rotatef((float) Math.toDegrees(vrPlayer.vrdata_world_render.rotation_radians), 0, 1, 0);
+		//
+		// scale everything in the room
+		GlStateManager.scalef(vrPlayer.vrdata_world_render.worldScale, vrPlayer.vrdata_world_render.worldScale,
+				vrPlayer.vrdata_world_render.worldScale);
+		///
+
+		// Device Pose
+		Vec3d cp = vrPlayer.vrdata_room_pre.getController(2).getPosition();
+
+		GlStateManager.translated(-cp.x, -cp.y, -cp.z);
+
+		// this is here because.
+		GlStateManager.multMatrix(conrot);
+
+		if (MCOpenVR.mrMovingCamActive) {
+			// local offsets
+			GlStateManager.translatef(vrSettings.mrMovingCamOffsetX, vrSettings.mrMovingCamOffsetY,
+					vrSettings.mrMovingCamOffsetZ);
+
+			// local rots
+			GlStateManager.multMatrix(
+					Utils.convertToOVRMatrix(vrSettings.mrMovingCamOffsetRotQuat.getMatrix()).toFloatBuffer());
+			// GlStateManager.rotatef(vrSettings.mrMovingCamOffsetYaw, 0.0F, 1.0F, 0.0F);
+			// GlStateManager.rotatef(vrSettings.mrMovingCamOffsetRoll, 0.0F, 0.0F, 1.0F);
+			// GlStateManager.rotatef(vrSettings.mrMovingCamOffsetPitch, 1.0F, 0.0F, 0.0F);
+		}
+
+		// put back scale
+		GlStateManager.scalef(1 / vrPlayer.vrdata_world_render.worldScale, 1 / vrPlayer.vrdata_world_render.worldScale,
+				1 / vrPlayer.vrdata_world_render.worldScale);
+		//
+
+		GL11.glGetFloatv(GL11.GL_MODELVIEW_MATRIX, matrixBuffer);
+		GlStateManager.popMatrix();
+
+		matrixBuffer.rewind();
+		this.thirdPassViewMatrix.load(matrixBuffer);
+		matrixBuffer.rewind();
+		return thirdPassViewMatrix;
+	}
+
+	public void printGLMatrix(String derp) {
+		GL11.glGetFloatv(GL11.GL_MODELVIEW_MATRIX, matrixBuffer);
+		matrixBuffer.rewind();
+		Matrix4f temp = new Matrix4f();
+		temp.load(matrixBuffer);
+		System.out.println(derp + "\r\n" + temp.toString());
+		matrixBuffer.rewind();
+	}
+
+	public void clearGLError() // bad bad bad
+	{
+		int var2 = GL11.glGetError();
+	}
+
+	// public org.lwjgl.util.vector.Matrix4f thirdPassInverseViewMatrix = new
+	// org.lwjgl.util.vector.Matrix4f();
+	public org.vivecraft.utils.lwjgl.Matrix4f thirdPassViewMatrix = new Matrix4f();
+
+	private boolean copyToMirror(RenderPass currentPass2) {
+		// VIVE start - render eye buffers to the desktop window
+
+		if (this.vrSettings.displayMirrorMode < vrSettings.MIRROR_OFF) // new values
+			this.vrSettings.displayMirrorMode = vrSettings.MIRROR_ON_DUAL;
+
+		if (this.vrSettings.displayMirrorMode > vrSettings.MIRROR_MIXED_REALITY) // new values
+			this.vrSettings.displayMirrorMode = vrSettings.MIRROR_ON_DUAL;
+
+		if (this.vrSettings.displayMirrorMode == vrSettings.MIRROR_OFF && MCOpenVR.isHMDTracking()) {
+			return false;
+		} else if (this.vrSettings.displayMirrorMode == vrSettings.MIRROR_MIXED_REALITY /*
+																						 * && renderViewEntity != null
+																						 */) {
+			if (currentPass2 != RenderPass.THIRD)
+				return false;
+
+			if (VRShaders._DepthMask_shaderProgramId != 0) {
+				doMixedRealityMirror();
+			} else {
+				this.framebuffer.unbindFramebuffer(); // draw directly to window
+				GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT);
+				gameRenderer.displayNotificationText("Shader compile failed, see log", "", "",
+						this.mainWindow.getWidth(), this.mainWindow.getHeight(), false, true);
+			}
+
+			return true;
+		} else { // left, right, undistorted, third.
+			int ports = 1;
+			Framebuffer source = stereoProvider.framebufferEye0;
+			int i = 0;
+
+			if (this.vrSettings.displayMirrorMode == vrSettings.MIRROR_FIRST_PERSON) {
+				source = stereoProvider.framebufferUndistorted;
+			} else if (this.vrSettings.displayMirrorMode == vrSettings.MIRROR_THIRD_PERSON) {
+				getMRTransform();
+				source = stereoProvider.framebufferMR;
+			} else if (this.vrSettings.displayMirrorMode == vrSettings.MIRROR_ON_DUAL) {
+				ports = 2;
+				if (currentPass2 == RenderPass.RIGHT) {
+					source = stereoProvider.framebufferEye1;
+					i = 1;
+				}
+			} else if (this.vrSettings.displayMirrorMode == vrSettings.MIRROR_ON_SINGLE) {
+				if (currentPass2 == RenderPass.LEFT)
+					return false;
+			}
+
+			this.framebuffer.unbindFramebuffer(); // draw directly to window
+			source.framebufferRenderExt((mainWindow.getFramebufferWidth() / 2) * i,
+					mainWindow.getFramebufferWidth() / ports, mainWindow.getFramebufferHeight(), 0, true);
+			return true;
+
+		}
+
+	}
+
+	private void doMixedRealityMirror() {
+		boolean hasShaders = Config.isShaders();
+		boolean alphaMask = this.vrSettings.mixedRealityUnityLike && this.vrSettings.mixedRealityAlphaMask;
+
+		this.framebuffer.unbindFramebuffer(); // draw directly to window
+
+		// GL30.glBindFramebuffer(GL30.GL_DRAW_FRAMEBUFFER, 0);
+		// GL30.glBindFramebuffer(GL30.GL_READ_FRAMEBUFFER,
+		// stereoProvider.framebufferMR.framebufferObject);
+
+		if (!alphaMask)
+			GlStateManager.clearColor(vrSettings.mixedRealityKeyColor.getRed() / 255F,
+					vrSettings.mixedRealityKeyColor.getGreen() / 255F, vrSettings.mixedRealityKeyColor.getBlue() / 255F,
+					1);
+		else
+			GlStateManager.clearColor(0, 0, 0, 1);
+		GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+
+		// create view matrix
+
+		// temp
+		// vrSettings.mrMovingCamOffsetPitch = 0;
+		// vrSettings.mrMovingCamOffsetYaw = 0;
+		// vrSettings.mrMovingCamOffsetRoll = 0f;
+		//
+		// vrSettings.mrMovingCamOffsetX = 0f;
+		// vrSettings.mrMovingCamOffsetY = 0f;
+		// vrSettings.mrMovingCamOffsetZ = 0f;
+		//
+		// vrSettings.vrFixedCamrotYaw = 0;
+		// vrSettings.vrFixedCamrotRoll = 0;
+		// vrSettings.vrFixedCamrotPitch= 0;
+		////
+		// vrSettings.vrFixedCamposX = 0;
+		// vrSettings.vrFixedCamposY = 0;
+		// vrSettings.vrFixedCamposZ= 0;
+		// vrSettings.saveOptions();
+		//
+		// vrSettings.vrWorldRotation +=1f;
+		// vrPlayer.checkandUpdateRotateScale(true, 0);
+		//
+
+		getMRTransform();
+
+		Vec3d derp = vrPlayer.vrdata_world_render.getController(2).getPosition();
+
+		Vec3d camplayer = new Vec3d(-thirdPassViewMatrix.m30, -thirdPassViewMatrix.m31, -thirdPassViewMatrix.m32)
+				.subtract(vrPlayer.vrdata_world_render.getEye(RenderPass.CENTER).getPosition());
+		// Vec3d camplayer =
+		// derp.subtract(vrPlayer.vrdata_world_render.getEye(renderPass.Center).getPosition());
+
+		camplayer = camplayer.rotateYaw((float) Math.PI);
+
+		// org.lwjgl.util.vector.Vector3f CameraLookx = new
+		// org.lwjgl.util.vector.Vector3f(0,0,-1);
+		// org.lwjgl.util.vector.Vector3f CameraLooky =
+		// Utils.directionFromMatrix(thirdPassViewMatrix, 0, 0, -1);
+		// float yaw = (float) Math.toRadians(-vrSettings.vrFixedCamrotYaw -
+		// vrSettings.vrWorldRotation);
+		// float yawx = (float)
+		// Math.atan2((-thirdPassViewMatrix.m20),(Math.sqrt(Math.pow(thirdPassViewMatrix.m21,
+		// 2) + Math.pow(thirdPassViewMatrix.m22, 2))));
+
+		// org.lwjgl.util.vector.Vector3f CameraLook = new
+		// org.lwjgl.util.vector.Vector3f((float) Math.sin(yaw), 0f,
+		// (float)Math.cos(yaw));
+
+		org.vivecraft.utils.lwjgl.Matrix4f viewMatrix = new org.vivecraft.utils.lwjgl.Matrix4f(thirdPassViewMatrix);
+		viewMatrix.m33 = 1;
+		viewMatrix.m30 = 0;
+		viewMatrix.m31 = 0;
+		viewMatrix.m32 = 0;
+
+		viewMatrix = (Matrix4f) viewMatrix.invert();
+
+		org.vivecraft.utils.lwjgl.Vector3f CameraLook = Utils.directionFromMatrix(viewMatrix, 0, 0, 1);
+
+		// Vec3d camplayerx =
+		// gameRenderer.getMRCamLocation().subtract(gameRenderer.getEyeRenderPos(renderPass.Center));
+
+		GLX.glUseProgram(VRShaders._DepthMask_shaderProgramId);
+
+		// set projection matrix
+		gameRenderer.thirdPassProjectionMatrix.write(matrixBuffer);
+		matrixBuffer.rewind();
+		ARBShaderObjects.glUniformMatrix4fvARB(VRShaders._DepthMask_projectionMatrix, false, matrixBuffer);
+
+		// set view matrix
+		viewMatrix.store(matrixBuffer);
+		matrixBuffer.rewind();
+		ARBShaderObjects.glUniformMatrix4fvARB(VRShaders._DepthMask_viewMatrix, false, matrixBuffer);
+
+		ARBShaderObjects.glUniform1iARB(VRShaders._DepthMask_colorTexUniform, 1);
+		ARBShaderObjects.glUniform1iARB(VRShaders._DepthMask_depthTexUniform, 2);
+		ARBShaderObjects.glUniform3fARB(VRShaders._DepthMask_hmdViewPosition, (float) camplayer.x, (float) camplayer.y,
+				(float) camplayer.z);
+		ARBShaderObjects.glUniform3fARB(VRShaders._DepthMask_hmdPlaneNormal, (float) -CameraLook.x, 0,
+				(float) CameraLook.z);
+		ARBShaderObjects.glUniform3fARB(VRShaders._DepthMask_keyColorUniform,
+				vrSettings.mixedRealityKeyColor.getRed() / 255F, vrSettings.mixedRealityKeyColor.getGreen() / 255F,
+				vrSettings.mixedRealityKeyColor.getBlue() / 255F);
+		ARBShaderObjects.glUniform1iARB(VRShaders._DepthMask_alphaModeUniform, alphaMask ? 1 : 0);
+
+		// bind color and depth textures
+		GlStateManager.activeTexture(GL13.GL_TEXTURE1);
+		stereoProvider.framebufferMR.bindFramebufferTexture();
+		GlStateManager.activeTexture(GL13.GL_TEXTURE2);
+
+		if (hasShaders)
+			GlStateManager.bindTexture(Shaders.dfbDepthTextures.get(0)); // shadersmod has it's own depth buffer
+		else
+			GlStateManager.bindTexture(stereoProvider.framebufferMR.depthBuffer);
+
+		GlStateManager.activeTexture(GL13.GL_TEXTURE0);
+
+		for (int i = 0; i < (alphaMask ? 3 : 2); i++) {
+
+			int resW = mainWindow.getFramebufferWidth() / 2;
+			int resH = mainWindow.getFramebufferHeight();
+			int posW = (mainWindow.getFramebufferWidth() / 2) * i;
+			int posH = 0;
+
+			if (this.vrSettings.mixedRealityUnityLike) {
+				resW = mainWindow.getFramebufferWidth() / 2;
+				resH = mainWindow.getFramebufferHeight() / 2;
+				if (this.vrSettings.mixedRealityAlphaMask && i == 2) {
+					posW = mainWindow.getFramebufferWidth() / 2;
+					posH = mainWindow.getFramebufferHeight() / 2;
+				} else {
+					posW = 0;
+					posH = (mainWindow.getFramebufferHeight() / 2) * (1 - i);
+				}
+			}
+
+			// set other uniforms
+			ARBShaderObjects.glUniform2fARB(VRShaders._DepthMask_resolutionUniform, resW, resH);
+			ARBShaderObjects.glUniform2fARB(VRShaders._DepthMask_positionUniform, posW, posH);
+			ARBShaderObjects.glUniform1iARB(VRShaders._DepthMask_passUniform, i);
+
+			// draw framebuffer
+			stereoProvider.framebufferMR.framebufferRenderExt(posW, resW, resH, posH, true);
+		}
+
+		GLX.glUseProgram(0);
+
+		if (this.vrSettings.mixedRealityUnityLike) {
+			if (this.vrSettings.mixedRealityMRPlusUndistorted)
+				stereoProvider.framebufferUndistorted.framebufferRenderExt(mainWindow.getFramebufferWidth() / 2,
+						mainWindow.getFramebufferWidth() / 2, mainWindow.getFramebufferHeight() / 2, 0, true);
+			else
+				stereoProvider.framebufferEye0.framebufferRenderExt(mainWindow.getFramebufferWidth() / 2,
+						mainWindow.getFramebufferWidth() / 2, mainWindow.getFramebufferHeight() / 2, 0, true);
+		}
+
+	}
+
+	private float fov = 1.0f;
+
+	private void checkGLError(String message) {
+		Config.checkGlError(message);
+	}
+
+	public void initMinecrift() throws Exception {
+		new MCOpenVR();
+		MCOpenVR.init();
+		this.stereoProvider = new OpenVRStereoRenderer();
+
+		this.vrPlayer = new OpenVRPlayer();
+		this.vrSettings.vrAllowCrawling = false;
+
+		stereoProvider.lastGuiScale = this.gameSettings.guiScale;
+
+		// register Trackers
+		vrPlayer.registerTracker(backpackTracker);
+		vrPlayer.registerTracker(bowTracker);
+		vrPlayer.registerTracker(climbTracker);
+		vrPlayer.registerTracker(autoFood);
+		vrPlayer.registerTracker(jumpTracker);
+		vrPlayer.registerTracker(rowTracker);
+		vrPlayer.registerTracker(runTracker);
+		vrPlayer.registerTracker(sneakTracker);
+		vrPlayer.registerTracker(swimTracker);
+		vrPlayer.registerTracker(swingTracker);
+		vrPlayer.registerTracker(interactTracker);
+		vrPlayer.registerTracker(teleportTracker);
+		vrPlayer.registerTracker(horseTracker);
+		vrPlayer.registerTracker(vehicleTracker);
+		vrPlayer.registerTracker(physicalGuiManager);
+	}
+
+	/**
+	 * Sets the listener of sounds
+	 */
+	public void updateSoundListener() {
+		Vec3d up = vrPlayer.vrdata_world_render.hmd.getCustomVector(new Vec3d(0, 1, 0));
+		Vec3d hmdPos = vrPlayer.vrdata_world_render.getHeadPivot();
+		Vec3d hmdDir = vrPlayer.vrdata_world_render.hmd.getDirection();
+		this.soundHandler.sndManager.setLikeNotARetard(hmdPos, hmdDir, up);
+	}
+
+	private static void sleepNanos(long nanoDelay) {
+		final long end = System.nanoTime() + nanoDelay;
+		do {
+			Thread.yield(); // This is a busy wait sadly...
+		} while (System.nanoTime() < end);
+	}
+
+	private void addRunTickTimeNanos(long runTickTime) {
+		int i = 0;
+		medianRunTickTimeNanos = runTickTime;
+
+		if (this.vrSettings.smoothRunTickCount < 1)
+			this.vrSettings.smoothRunTickCount = 1;
+
+		if (this.vrSettings.smoothRunTickCount % 2 == 0) {
+			// Need an odd number for this
+			this.vrSettings.smoothRunTickCount++;
+		}
+
+		runTickTimeNanos.addFirst(runTickTime);
+		while (runTickTimeNanos.size() > this.vrSettings.smoothRunTickCount)
+			runTickTimeNanos.removeLast();
+
+		if (runTickTimeNanos.size() == this.vrSettings.smoothRunTickCount) {
+			Long[] array = new Long[runTickTimeNanos.size()];
+			for (Iterator itr = runTickTimeNanos.iterator(); itr.hasNext(); i++) {
+				array[i] = (Long) itr.next();
+			}
+			Arrays.sort(array);
+			medianRunTickTimeNanos = array[array.length / 2];
+		}
+	}
+
+	private long getMedianRunTickTimeNanos() {
+		return medianRunTickTimeNanos;
+	}
+
+	public void triggerYawTransition(boolean isPositive) {
+		// this.lookaimController.triggerYawTransition(isPositive);
+	}
+
+	public void print(String s) {
+		s = s.replace("\n", "\n[Minecrift] ");
+		System.out.println("[Minecrift] " + s);
+	}
+
+	public float watereffect, portaleffect, pumpkineffect;
+
+	private boolean renderSingleView(int eye, float nano, boolean renderworld) {
+		boolean shouldupdate = false;
+
+		GlStateManager.clearColor(0f, 0, 0, 1f);
+		GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+		GlStateManager.enableTexture();
+		GlStateManager.enableDepthTest();
+
+		this.profiler.startSection("updateCameraAndRender");
+		if (!this.skipRenderWorld) {
+			// Forge calls onRenderTickStart > move to ER.drawFrameBuffer
+
+			/// THIS IS WHERE EVERYTHING IS RENDERED
+			this.gameRenderer.renderGame(nano, System.nanoTime(), renderworld);
+
+			// Forge calls onRenderTickEnd > move to ER.drawFrameBuffer
+		}
+		this.profiler.endSection();
+		checkGLError("post game render " + eye);
+
+		gameRenderer.itemRenderer.renderFaceOverlay(nano);
+		
+		if (currentPass == RenderPass.LEFT || currentPass == RenderPass.RIGHT) {
+			// copies the rendered scen-e to eye tex with fsaa and other postprocessing
+			// effects.
+			this.profiler.startSection("postprocesseye");
+
+			Framebuffer source = this.framebuffer;
+
+			if (this.vrSettings.useFsaa) {
+				this.profiler.startSection("fsaa");
+				stereoProvider.doFSAA(Config.isShaders());
+				source = stereoProvider.fsaaLastPassResultFBO;
+				checkGLError("fsaa " + eye);
+				this.profiler.endSection();
+			}
+
+			if (currentPass == RenderPass.LEFT)
+				stereoProvider.framebufferEye0.bindFramebuffer(true); // draw to L eye tex
+			else
+				stereoProvider.framebufferEye1.bindFramebuffer(true); // draw to R eye tex
+
+			if (vrSettings.useFOVReduction && vrPlayer.getFreeMove()) {
+				if (player != null && (Math.abs(player.moveForward) > 0 || Math.abs(player.moveStrafing) > 0)) {
+					fov -= 0.05;
+					if (fov < vrSettings.fovReductionMin)
+						fov = vrSettings.fovReductionMin;
+				} else {
+					fov += 0.01;
+					if (fov > 0.8)
+						fov = 0.8f;
+				}
+			} else {
+				fov = 1f;
+			}
+
+			ARBShaderObjects.glUseProgramObjectARB(VRShaders._FOVReduction_shaderProgramId);
+			ARBShaderObjects.glUniform1iARB(VRShaders._FOVReduction_TextureUniform, 0);
+			ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_OffsetUniform, vrSettings.fovRedutioncOffset);
+
+			if (pumpkineffect > 0) {
+				ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_RadiusUniform, 0.3f);
+				ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_BorderUniform, 0.0f);
+			} else {
+				ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_RadiusUniform, fov);
+				ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_BorderUniform, 0.06f);
+			}
+
+			// VIVE start - screen flash when hurt instead of view tilt
+			float r = 0, k = 0;
+			// VIVE start - screen flash when hurt instead of view tilt
+			float time = (float) Util.milliTime() / 1000;
+			if (player != null && world != null) {
+
+				if (gameRenderer.wasinwater != gameRenderer.inwater) {
+					watereffect = 2.3f;
+				} else {
+					if (gameRenderer.inwater) {
+						watereffect -= (1f / 120f);
+					} else {
+						watereffect -= (1f / 60f);
+					}
+					if (watereffect < 0)
+						watereffect = 0;
+				}
+
+				gameRenderer.wasinwater = gameRenderer.inwater;
+
+				if (Config.isShaders())
+					watereffect = 0; // dont stack.
+
+				if (gameRenderer.inportal) {
+					portaleffect = 1f;
+				} else {
+					portaleffect -= (1f / 60f);
+					if (portaleffect < 0)
+						portaleffect = 0;
+				}
+
+				float var3 = (float) player.hurtTime - nano;
+
+				float percent = 1 - player.getHealth() / player.getMaxHealth();
+				percent = (percent - 0.5f) * 0.75f;
+
+				if (var3 > 0.0f) {
+					var3 /= (float) player.maxHurtTime;
+					var3 = percent + MathHelper.sin(var3 * var3 * var3 * var3 * (float) Math.PI) * 0.5f;
+					r = var3;
+				} else {
+					r = (float) (percent * Math.abs(Math.sin(2.5f * time / (1 - percent + .1))));
+					if (player.isCreative())
+						r = 0;
+				}
+
+				if (gameRenderer.inblock && player.isAlive()) {
+					// k = (float) gameRenderer.itemRenderer.inBlock;
+				}
+
+				if (player.isSleeping()) {
+					if (k < 0.8)
+						k = .8f;
+				}
+
+				if (MCOpenVR.isWalkingAbout) {
+					if (k < 0.8)
+						k = .5f;
+				}
+
+			} else {
+				watereffect = 0;
+				portaleffect = 0;
+			}
+
+			ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_HealthAlpha, r);
+			ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_BlackAlpha, k);
+			ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_time, time);
+			ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_waterAmplitude, watereffect);
+			ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_portalAmplitutde, portaleffect);
+			ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_pumpkinAmplitutde, pumpkineffect);
+			ARBShaderObjects.glUniform1iARB(VRShaders._Overlay_eye, currentPass == currentPass.LEFT ? 1 : -1);
+
+			source.framebufferRender(stereoProvider.framebufferEye0.framebufferWidth,
+					stereoProvider.framebufferEye0.framebufferHeight);
+
+			ARBShaderObjects.glUseProgramObjectARB(0);
+
+			checkGLError("post overlay" + eye);
+
+			this.profiler.endSection();
+
+			// this.mcProfiler.startSection("OpenGL Finish");
+			// GL11.glFinish();//DO NOT LEAVE THIS UNCOMMENTED
+			// this.mcProfiler.endSection();
+
+		}
+
+		this.profiler.startSection("mirror");
+		shouldupdate = copyToMirror(this.currentPass);
+		checkGLError("post-mirror " + eye);
+		this.profiler.endSection();
+
+		return shouldupdate;
+	}
+
+	private float frameDelta, prevFrameTime;
+
+	public float getFrameDelta() {
+		return frameDelta;
+	}
+
+	private float angleNormalize(float angle) {
+		angle %= 360;
+		if (angle < 0)
+			angle += 360;
+		return angle;
+	}
+
+	private float angleDiff(float a, float b) {
+		float d = Math.abs(a - b) % 360;
+		float r = d > 180 ? 360 - d : d;
+
+		int sign = (a - b >= 0 && a - b <= 180) || (a - b <= -180 && a - b >= -360) ? 1 : -1;
+		return r * sign;
+
+	}
+
+	// FORGE
+	public ItemColors getItemColors() {
+		return this.itemColors;
+	}
+
+	public SearchTreeManager getSearchTreeManager() {
+		return this.searchTreeManager;
+	}
+	//
+
+	public void loadClassPath() {
+		File resourceRoot = new File("../src/resources");
+		if (!resourceRoot.exists() || !resourceRoot.isDirectory())
+			return;
+		Method method = null;
+		try {
+			method = URLClassLoader.class.getDeclaredMethod("addURL", URL.class);
+			method.setAccessible(true);
+			method.invoke(ClassLoader.getSystemClassLoader(), resourceRoot.toURI().toURL());
+		} catch (Exception e) {
+			e.printStackTrace();
+		}
+
+	}
+
 }
