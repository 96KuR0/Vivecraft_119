--- a/net/minecraft/client/resources/model/ModelBakery.java
+++ b/net/minecraft/client/resources/model/ModelBakery.java
@@ -37,6 +37,7 @@
 import javax.annotation.Nullable;
 import net.minecraft.Util;
 import net.minecraft.client.color.block.BlockColors;
+import net.minecraft.client.renderer.GameRenderer;
 import net.minecraft.client.renderer.RenderType;
 import net.minecraft.client.renderer.Sheets;
 import net.minecraft.client.renderer.block.BlockModelShaper;
@@ -73,6 +74,8 @@
 import org.apache.commons.lang3.tuple.Triple;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.vivecraft.gameplay.trackers.CameraTracker;
+import org.vivecraft.gameplay.trackers.TelescopeTracker;
 
 public class ModelBakery
 {
@@ -84,45 +87,45 @@
     public static final Material BANNER_BASE = new Material(TextureAtlas.LOCATION_BLOCKS, new ResourceLocation("entity/banner_base"));
     public static final Material SHIELD_BASE = new Material(TextureAtlas.LOCATION_BLOCKS, new ResourceLocation("entity/shield_base"));
     public static final Material NO_PATTERN_SHIELD = new Material(TextureAtlas.LOCATION_BLOCKS, new ResourceLocation("entity/shield_base_nopattern"));
-    public static final List<ResourceLocation> DESTROY_STAGES = IntStream.range(0, 10).mapToObj((p_229323_0_) ->
+    public static final List<ResourceLocation> DESTROY_STAGES = IntStream.range(0, 10).mapToObj((p_lambda$static$0_0_) ->
     {
-        return new ResourceLocation("block/destroy_stage_" + p_229323_0_);
+        return new ResourceLocation("block/destroy_stage_" + p_lambda$static$0_0_);
     }).collect(Collectors.toList());
-    public static final List<ResourceLocation> BREAKING_LOCATIONS = DESTROY_STAGES.stream().map((p_229351_0_) ->
+    public static final List<ResourceLocation> BREAKING_LOCATIONS = DESTROY_STAGES.stream().map((p_lambda$static$1_0_) ->
     {
-        return new ResourceLocation("textures/" + p_229351_0_.getPath() + ".png");
+        return new ResourceLocation("textures/" + p_lambda$static$1_0_.getPath() + ".png");
     }).collect(Collectors.toList());
     public static final List<RenderType> DESTROY_TYPES = BREAKING_LOCATIONS.stream().map(RenderType::crumbling).collect(Collectors.toList());
-    private static final Set<Material> UNREFERENCED_TEXTURES = Util.make(Sets.newHashSet(), (p_229337_0_) ->
+    private static final Set<Material> UNREFERENCED_TEXTURES = Util.make(Sets.newHashSet(), (p_lambda$static$2_0_) ->
     {
-        p_229337_0_.add(WATER_FLOW);
-        p_229337_0_.add(LAVA_FLOW);
-        p_229337_0_.add(WATER_OVERLAY);
-        p_229337_0_.add(FIRE_0);
-        p_229337_0_.add(FIRE_1);
-        p_229337_0_.add(BellRenderer.BELL_RESOURCE_LOCATION);
-        p_229337_0_.add(ConduitRenderer.SHELL_TEXTURE);
-        p_229337_0_.add(ConduitRenderer.ACTIVE_SHELL_TEXTURE);
-        p_229337_0_.add(ConduitRenderer.WIND_TEXTURE);
-        p_229337_0_.add(ConduitRenderer.VERTICAL_WIND_TEXTURE);
-        p_229337_0_.add(ConduitRenderer.OPEN_EYE_TEXTURE);
-        p_229337_0_.add(ConduitRenderer.CLOSED_EYE_TEXTURE);
-        p_229337_0_.add(EnchantTableRenderer.BOOK_LOCATION);
-        p_229337_0_.add(BANNER_BASE);
-        p_229337_0_.add(SHIELD_BASE);
-        p_229337_0_.add(NO_PATTERN_SHIELD);
+        p_lambda$static$2_0_.add(WATER_FLOW);
+        p_lambda$static$2_0_.add(LAVA_FLOW);
+        p_lambda$static$2_0_.add(WATER_OVERLAY);
+        p_lambda$static$2_0_.add(FIRE_0);
+        p_lambda$static$2_0_.add(FIRE_1);
+        p_lambda$static$2_0_.add(BellRenderer.BELL_RESOURCE_LOCATION);
+        p_lambda$static$2_0_.add(ConduitRenderer.SHELL_TEXTURE);
+        p_lambda$static$2_0_.add(ConduitRenderer.ACTIVE_SHELL_TEXTURE);
+        p_lambda$static$2_0_.add(ConduitRenderer.WIND_TEXTURE);
+        p_lambda$static$2_0_.add(ConduitRenderer.VERTICAL_WIND_TEXTURE);
+        p_lambda$static$2_0_.add(ConduitRenderer.OPEN_EYE_TEXTURE);
+        p_lambda$static$2_0_.add(ConduitRenderer.CLOSED_EYE_TEXTURE);
+        p_lambda$static$2_0_.add(EnchantTableRenderer.BOOK_LOCATION);
+        p_lambda$static$2_0_.add(BANNER_BASE);
+        p_lambda$static$2_0_.add(SHIELD_BASE);
+        p_lambda$static$2_0_.add(NO_PATTERN_SHIELD);
 
         for (ResourceLocation resourcelocation : DESTROY_STAGES)
         {
-            p_229337_0_.add(new Material(TextureAtlas.LOCATION_BLOCKS, resourcelocation));
+            p_lambda$static$2_0_.add(new Material(TextureAtlas.LOCATION_BLOCKS, resourcelocation));
         }
 
-        p_229337_0_.add(new Material(TextureAtlas.LOCATION_BLOCKS, InventoryMenu.EMPTY_ARMOR_SLOT_HELMET));
-        p_229337_0_.add(new Material(TextureAtlas.LOCATION_BLOCKS, InventoryMenu.EMPTY_ARMOR_SLOT_CHESTPLATE));
-        p_229337_0_.add(new Material(TextureAtlas.LOCATION_BLOCKS, InventoryMenu.EMPTY_ARMOR_SLOT_LEGGINGS));
-        p_229337_0_.add(new Material(TextureAtlas.LOCATION_BLOCKS, InventoryMenu.EMPTY_ARMOR_SLOT_BOOTS));
-        p_229337_0_.add(new Material(TextureAtlas.LOCATION_BLOCKS, InventoryMenu.EMPTY_ARMOR_SLOT_SHIELD));
-        Sheets.getAllMaterials(p_229337_0_::add);
+        p_lambda$static$2_0_.add(new Material(TextureAtlas.LOCATION_BLOCKS, InventoryMenu.EMPTY_ARMOR_SLOT_HELMET));
+        p_lambda$static$2_0_.add(new Material(TextureAtlas.LOCATION_BLOCKS, InventoryMenu.EMPTY_ARMOR_SLOT_CHESTPLATE));
+        p_lambda$static$2_0_.add(new Material(TextureAtlas.LOCATION_BLOCKS, InventoryMenu.EMPTY_ARMOR_SLOT_LEGGINGS));
+        p_lambda$static$2_0_.add(new Material(TextureAtlas.LOCATION_BLOCKS, InventoryMenu.EMPTY_ARMOR_SLOT_BOOTS));
+        p_lambda$static$2_0_.add(new Material(TextureAtlas.LOCATION_BLOCKS, InventoryMenu.EMPTY_ARMOR_SLOT_SHIELD));
+        Sheets.getAllMaterials(p_lambda$static$2_0_::add);
     });
     private static final Logger LOGGER = LogManager.getLogger();
     public static final ModelResourceLocation MISSING_MODEL_LOCATION = new ModelResourceLocation("builtin/missing", "missing");
@@ -132,13 +135,13 @@
     private static final Map<String, String> BUILTIN_MODELS = Maps.newHashMap(ImmutableMap.of("missing", MISSING_MODEL_MESH));
     private static final Splitter COMMA_SPLITTER = Splitter.on(',');
     private static final Splitter EQUAL_SPLITTER = Splitter.on('=').limit(2);
-    public static final BlockModel GENERATION_MARKER = Util.make(BlockModel.fromString("{\"gui_light\": \"front\"}"), (p_229347_0_) ->
+    public static final BlockModel GENERATION_MARKER = Util.make(BlockModel.fromString("{\"gui_light\": \"front\"}"), (p_lambda$static$3_0_) ->
     {
-        p_229347_0_.name = "generation marker";
+        p_lambda$static$3_0_.name = "generation marker";
     });
-    public static final BlockModel BLOCK_ENTITY_MARKER = Util.make(BlockModel.fromString("{\"gui_light\": \"side\"}"), (p_229332_0_) ->
+    public static final BlockModel BLOCK_ENTITY_MARKER = Util.make(BlockModel.fromString("{\"gui_light\": \"side\"}"), (p_lambda$static$4_0_) ->
     {
-        p_229332_0_.name = "block entity marker";
+        p_lambda$static$4_0_.name = "block entity marker";
     });
     private static final StateDefinition<Block, BlockState> ITEM_FRAME_FAKE_DEFINITION = (new StateDefinition.Builder<Block, BlockState>(Blocks.AIR)).m_61104_(BooleanProperty.create("map")).create(Block::defaultBlockState, BlockState::new);
     private static final ItemModelGenerator ITEM_MODEL_GENERATOR = new ItemModelGenerator();
@@ -155,9 +158,9 @@
     private final Map<ResourceLocation, BakedModel> bakedTopLevelModels = Maps.newHashMap();
     private Map<ResourceLocation, Pair<TextureAtlas, TextureAtlas.Preparations>> atlasPreparations;
     private int nextModelGroup = 1;
-    private final Object2IntMap<BlockState> modelGroups = Util.make(new Object2IntOpenHashMap<>(), (p_229336_0_) ->
+    private final Object2IntMap<BlockState> modelGroups = Util.make(new Object2IntOpenHashMap<>(), (p_lambda$new$5_0_) ->
     {
-        p_229336_0_.defaultReturnValue(-1);
+        p_lambda$new$5_0_.defaultReturnValue(-1);
     });
     public Map<ResourceLocation, UnbakedModel> mapUnbakedModels;
 
@@ -167,16 +170,16 @@
         this.processLoading(p_119249_, p_119250_);
     }
 
-    protected ModelBakery(ResourceManager resourceManagerIn, BlockColors blockColorsIn, boolean vanillaBakery)
+    protected ModelBakery(ResourceManager p_i242117_1_, BlockColors p_i242117_2_, boolean p_i242117_3_)
     {
-        this.resourceManager = resourceManagerIn;
-        this.blockColors = blockColorsIn;
+        this.resourceManager = p_i242117_1_;
+        this.blockColors = p_i242117_2_;
     }
 
-    protected void processLoading(ProfilerFiller profilerIn, int maxMipmapLevel)
+    protected void processLoading(ProfilerFiller p_processLoading_1_, int p_processLoading_2_)
     {
         Reflector.ModelLoaderRegistry_onModelLoadingStart.callVoid();
-        profilerIn.push("missing_model");
+        p_processLoading_1_.push("missing_model");
 
         try
         {
@@ -189,31 +192,36 @@
             throw new RuntimeException(ioexception);
         }
 
-        profilerIn.popPush("static_definitions");
-        STATIC_DEFINITIONS.forEach((p_229344_1_, p_229344_2_) ->
+        p_processLoading_1_.popPush("static_definitions");
+        STATIC_DEFINITIONS.forEach((p_lambda$processLoading$7_1_, p_lambda$processLoading$7_2_) ->
         {
-            p_229344_2_.getPossibleStates().forEach((p_229343_2_) -> {
-                this.loadTopLevel(BlockModelShaper.stateToModelLocation(p_229344_1_, p_229343_2_));
+            p_lambda$processLoading$7_2_.getPossibleStates().forEach((p_lambda$null$6_2_) -> {
+                this.loadTopLevel(BlockModelShaper.stateToModelLocation(p_lambda$processLoading$7_1_, p_lambda$null$6_2_));
             });
         });
-        profilerIn.popPush("blocks");
+        p_processLoading_1_.popPush("blocks");
 
         for (Block block : Registry.BLOCK)
         {
-            block.getStateDefinition().getPossibleStates().forEach((p_229326_1_) ->
+            block.getStateDefinition().getPossibleStates().forEach((p_lambda$processLoading$8_1_) ->
             {
-                this.loadTopLevel(BlockModelShaper.stateToModelLocation(p_229326_1_));
+                this.loadTopLevel(BlockModelShaper.stateToModelLocation(p_lambda$processLoading$8_1_));
             });
         }
 
-        profilerIn.popPush("items");
+        this.loadTopLevel(TelescopeTracker.scopeModel);
+        this.loadTopLevel(GameRenderer.thirdPersonCameraModel);
+        this.loadTopLevel(GameRenderer.thirdPersonCameraDisplayModel);
+        this.loadTopLevel(CameraTracker.cameraModel);
+        this.loadTopLevel(CameraTracker.cameraDisplayModel);
+        p_processLoading_1_.popPush("items");
 
         for (ResourceLocation resourcelocation : Registry.ITEM.keySet())
         {
             this.loadTopLevel(new ModelResourceLocation(resourcelocation, "inventory"));
         }
 
-        profilerIn.popPush("special");
+        p_processLoading_1_.popPush("special");
         this.loadTopLevel(new ModelResourceLocation("minecraft:trident_in_hand#inventory"));
 
         for (ResourceLocation resourcelocation1 : this.getSpecialModels())
@@ -221,35 +229,35 @@
             this.addModelToCache(resourcelocation1);
         }
 
-        profilerIn.popPush("textures");
+        p_processLoading_1_.popPush("textures");
         this.mapUnbakedModels = this.unbakedCache;
         TextureUtils.registerCustomModels(this);
         Set<Pair<String, String>> set = Sets.newLinkedHashSet();
-        Set<Material> set1 = this.topLevelModels.values().stream().flatMap((p_229342_2_) ->
+        Set<Material> set1 = this.topLevelModels.values().stream().flatMap((p_lambda$processLoading$9_2_) ->
         {
-            return p_229342_2_.getMaterials(this::getModel, set).stream();
+            return p_lambda$processLoading$9_2_.getMaterials(this::getModel, set).stream();
         }).collect(Collectors.toSet());
         set1.addAll(UNREFERENCED_TEXTURES);
         Reflector.call(Reflector.ForgeHooksClient_gatherFluidTextures, set1);
-        set.stream().filter((p_229346_0_) ->
+        set.stream().filter((p_lambda$processLoading$10_0_) ->
         {
-            return !p_229346_0_.getSecond().equals(MISSING_MODEL_LOCATION_STRING);
-        }).forEach((p_229330_0_) ->
+            return !p_lambda$processLoading$10_0_.getSecond().equals(MISSING_MODEL_LOCATION_STRING);
+        }).forEach((p_lambda$processLoading$11_0_) ->
         {
-            LOGGER.warn("Unable to resolve texture reference: {} in {}", p_229330_0_.getFirst(), p_229330_0_.getSecond());
+            LOGGER.warn("Unable to resolve texture reference: {} in {}", p_lambda$processLoading$11_0_.getFirst(), p_lambda$processLoading$11_0_.getSecond());
         });
         Map<ResourceLocation, List<Material>> map = set1.stream().collect(Collectors.groupingBy(Material::atlasLocation));
-        profilerIn.popPush("stitching");
+        p_processLoading_1_.popPush("stitching");
         this.atlasPreparations = Maps.newHashMap();
 
         for (Entry<ResourceLocation, List<Material>> entry : map.entrySet())
         {
             TextureAtlas textureatlas = new TextureAtlas(entry.getKey());
-            TextureAtlas.Preparations textureatlas$preparations = textureatlas.prepareToStitch(this.resourceManager, entry.getValue().stream().map(Material::texture), profilerIn, maxMipmapLevel);
+            TextureAtlas.Preparations textureatlas$preparations = textureatlas.prepareToStitch(this.resourceManager, entry.getValue().stream().map(Material::texture), p_processLoading_1_, p_processLoading_2_);
             this.atlasPreparations.put(entry.getKey(), Pair.of(textureatlas, textureatlas$preparations));
         }
 
-        profilerIn.pop();
+        p_processLoading_1_.pop();
     }
 
     public AtlasSet uploadTextures(TextureManager p_119299_, ProfilerFiller p_119300_)
@@ -268,21 +276,21 @@
 
         this.atlasSet = new AtlasSet(this.atlasPreparations.values().stream().map(Pair::getFirst).collect(Collectors.toList()));
         p_119300_.popPush("baking");
-        this.topLevelModels.keySet().forEach((p_229350_1_) ->
+        this.topLevelModels.keySet().forEach((p_lambda$uploadTextures$12_1_) ->
         {
             BakedModel bakedmodel = null;
 
             try {
-                bakedmodel = this.bake(p_229350_1_, BlockModelRotation.X0_Y0);
+                bakedmodel = this.bake(p_lambda$uploadTextures$12_1_, BlockModelRotation.X0_Y0);
             }
             catch (Exception exception)
             {
-                LOGGER.warn("Unable to bake model: '{}': {}", p_229350_1_, exception);
+                LOGGER.warn("Unable to bake model: '{}': {}", p_lambda$uploadTextures$12_1_, exception);
             }
 
             if (bakedmodel != null)
             {
-                this.bakedTopLevelModels.put(p_229350_1_, bakedmodel);
+                this.bakedTopLevelModels.put(p_lambda$uploadTextures$12_1_, bakedmodel);
             }
         });
         p_119300_.pop();
@@ -322,13 +330,13 @@
         }
 
         Block block = p_119274_.getOwner();
-        return (p_229325_2_) ->
+        return (p_lambda$parseVariantKey$13_2_) ->
         {
-            if (p_229325_2_ != null && block == p_229325_2_.getBlock())
+            if (p_lambda$parseVariantKey$13_2_ != null && block == p_lambda$parseVariantKey$13_2_.getBlock())
             {
                 for (Entry < Property<?>, Comparable<? >> entry : map.entrySet())
                 {
-                    if (!Objects.equals(p_229325_2_.getValue(entry.getKey()), entry.getValue()))
+                    if (!Objects.equals(p_lambda$parseVariantKey$13_2_.getValue(entry.getKey()), entry.getValue()))
                     {
                         return false;
                     }
@@ -405,34 +413,20 @@
         {
             ModelResourceLocation modelresourcelocation = (ModelResourceLocation)p_119363_;
 
-            if (Objects.equals(modelresourcelocation.getVariant(), "inventory"))
+            if (!Objects.equals(modelresourcelocation.getVariant(), "inventory"))
             {
-                ResourceLocation resourcelocation2 = new ResourceLocation(p_119363_.getNamespace(), "item/" + p_119363_.getPath());
-                String s = p_119363_.getPath();
-
-                if (s.startsWith("optifine/") || s.startsWith("item/"))
-                {
-                    resourcelocation2 = p_119363_;
-                }
-
-                BlockModel blockmodel = this.loadBlockModel(resourcelocation2);
-                this.cacheAndQueueDependencies(modelresourcelocation, blockmodel);
-                this.unbakedCache.put(resourcelocation2, blockmodel);
-            }
-            else
-            {
-                ResourceLocation resourcelocation = new ResourceLocation(p_119363_.getNamespace(), p_119363_.getPath());
-                StateDefinition<Block, BlockState> statedefinition = Optional.ofNullable(STATIC_DEFINITIONS.get(resourcelocation)).orElseGet(() ->
+                ResourceLocation resourcelocation2 = new ResourceLocation(p_119363_.getNamespace(), p_119363_.getPath());
+                StateDefinition<Block, BlockState> statedefinition = Optional.ofNullable(STATIC_DEFINITIONS.get(resourcelocation2)).orElseGet(() ->
                 {
-                    return Registry.BLOCK.get(resourcelocation).getStateDefinition();
+                    return Registry.BLOCK.get(resourcelocation2).getStateDefinition();
                 });
                 this.context.setDefinition(statedefinition);
-                List < Property<? >> list = ImmutableList.copyOf(this.blockColors.getColoringProperties(statedefinition.getOwner()));
+                List < Property<? >> list1 = ImmutableList.copyOf(this.blockColors.getColoringProperties(statedefinition.getOwner()));
                 ImmutableList<BlockState> immutablelist = statedefinition.getPossibleStates();
                 Map<ModelResourceLocation, BlockState> map = Maps.newHashMap();
-                immutablelist.forEach((p_229340_2_) ->
+                immutablelist.forEach((p_lambda$loadBlockstate$15_2_) ->
                 {
-                    BlockState blockstate = map.put(BlockModelShaper.stateToModelLocation(resourcelocation, p_229340_2_), p_229340_2_);
+                    BlockState blockstate = map.put(BlockModelShaper.stateToModelLocation(resourcelocation2, p_lambda$loadBlockstate$15_2_), p_lambda$loadBlockstate$15_2_);
                 });
                 Map<BlockState, Pair<UnbakedModel, Supplier<ModelBakery.ModelGroupKey>>> map1 = Maps.newHashMap();
                 ResourceLocation resourcelocation1 = new ResourceLocation(p_119363_.getNamespace(), "blockstates/" + p_119363_.getPath() + ".json");
@@ -445,19 +439,19 @@
 
                 try
                 {
-                    List<Pair<String, BlockModelDefinition>> list1;
+                    List<Pair<String, BlockModelDefinition>> list;
 
                     try
                     {
-                        list1 = this.resourceManager.getResources(resourcelocation1).stream().map((p_229345_1_) ->
+                        list = this.resourceManager.getResources(resourcelocation1).stream().map((p_lambda$loadBlockstate$17_1_) ->
                         {
-                            try (InputStream inputstream = p_229345_1_.getInputStream())
+                            try (InputStream inputstream = p_lambda$loadBlockstate$17_1_.getInputStream())
                             {
-                                return Pair.of(p_229345_1_.getSourceName(), BlockModelDefinition.fromStream(this.context, new InputStreamReader(inputstream, StandardCharsets.UTF_8)));
+                                return Pair.of(p_lambda$loadBlockstate$17_1_.getSourceName(), BlockModelDefinition.fromStream(this.context, new InputStreamReader(inputstream, StandardCharsets.UTF_8)));
                             }
-                            catch (Exception exception11)
+                            catch (Exception exception1)
                             {
-                                throw new ModelBakery.BlockStateDefinitionException(String.format("Exception loading blockstate definition: '%s' in resourcepack: '%s': %s", p_229345_1_.getLocation(), p_229345_1_.getSourceName(), exception11.getMessage()));
+                                throw new ModelBakery.BlockStateDefinitionException(String.format("Exception loading blockstate definition: '%s' in resourcepack: '%s': %s", p_lambda$loadBlockstate$17_1_.getLocation(), p_lambda$loadBlockstate$17_1_.getSourceName(), exception1.getMessage()));
                             }
                         }).collect(Collectors.toList());
                     }
@@ -467,7 +461,7 @@
                         return;
                     }
 
-                    for (Pair<String, BlockModelDefinition> pair1 : list1)
+                    for (Pair<String, BlockModelDefinition> pair1 : list)
                     {
                         BlockModelDefinition blockmodeldefinition = pair1.getSecond();
                         Map<BlockState, Pair<UnbakedModel, Supplier<ModelBakery.ModelGroupKey>>> map2 = Maps.newIdentityHashMap();
@@ -476,10 +470,10 @@
                         if (blockmodeldefinition.isMultiPart())
                         {
                             multipart = blockmodeldefinition.getMultiPart();
-                            immutablelist.forEach((p_229339_3_) ->
+                            immutablelist.forEach((p_lambda$loadBlockstate$19_3_) ->
                             {
-                                Pair pair2 = map2.put(p_229339_3_, Pair.of(multipart, () -> {
-                                    return ModelBakery.ModelGroupKey.create(p_229339_3_, multipart, list);
+                                Pair pair2 = map2.put(p_lambda$loadBlockstate$19_3_, Pair.of(multipart, () -> {
+                                    return ModelBakery.ModelGroupKey.create(p_lambda$loadBlockstate$19_3_, multipart, list1);
                                 }));
                             });
                         }
@@ -488,27 +482,27 @@
                             multipart = null;
                         }
 
-                        blockmodeldefinition.getVariants().forEach((p_229329_9_, p_229329_10_) ->
+                        blockmodeldefinition.getVariants().forEach((p_lambda$loadBlockstate$23_9_, p_lambda$loadBlockstate$23_10_) ->
                         {
                             try {
-                                immutablelist.stream().filter(predicate(statedefinition, p_229329_9_)).forEach((p_229338_6_) -> {
-                                    Pair<UnbakedModel, Supplier<ModelBakery.ModelGroupKey>> pair2 = map2.put(p_229338_6_, Pair.of(p_229329_10_, () -> {
-                                        return ModelBakery.ModelGroupKey.create(p_229338_6_, p_229329_10_, list);
+                                immutablelist.stream().filter(predicate(statedefinition, p_lambda$loadBlockstate$23_9_)).forEach((p_lambda$null$22_6_) -> {
+                                    Pair<UnbakedModel, Supplier<ModelBakery.ModelGroupKey>> pair2 = map2.put(p_lambda$null$22_6_, Pair.of(p_lambda$loadBlockstate$23_10_, () -> {
+                                        return ModelBakery.ModelGroupKey.create(p_lambda$null$22_6_, p_lambda$loadBlockstate$23_10_, list1);
                                     }));
 
                                     if (pair2 != null && pair2.getFirst() != multipart)
                                     {
-                                        map2.put(p_229338_6_, pair);
-                                        throw new RuntimeException("Overlapping definition with: " + (String)blockmodeldefinition.getVariants().entrySet().stream().filter((p_229331_1_) ->
+                                        map2.put(p_lambda$null$22_6_, pair);
+                                        throw new RuntimeException("Overlapping definition with: " + (String)blockmodeldefinition.getVariants().entrySet().stream().filter((p_lambda$null$21_1_) ->
                                         {
-                                            return p_229331_1_.getValue() == pair2.getFirst();
+                                            return p_lambda$null$21_1_.getValue() == pair2.getFirst();
                                         }).findFirst().get().getKey());
                                     }
                                 });
                             }
                             catch (Exception exception1)
                             {
-                                LOGGER.warn("Exception loading blockstate definition: '{}' in resourcepack: '{}' for variant: '{}': {}", resourcelocation1, pair1.getFirst(), p_229329_9_, exception1.getMessage());
+                                LOGGER.warn("Exception loading blockstate definition: '{}' in resourcepack: '{}' for variant: '{}': {}", resourcelocation1, pair1.getFirst(), p_lambda$loadBlockstate$23_9_, exception1.getMessage());
                             }
                         });
                         map1.putAll(map2);
@@ -520,39 +514,39 @@
                 {
                     throw modelbakery$blockstatedefinitionexception;
                 }
-                catch (Exception exception1)
+                catch (Exception exception)
                 {
-                    throw new ModelBakery.BlockStateDefinitionException(String.format("Exception loading blockstate definition: '%s': %s", resourcelocation1, exception1));
+                    throw new ModelBakery.BlockStateDefinitionException(String.format("Exception loading blockstate definition: '%s': %s", resourcelocation1, exception));
                 }
                 finally
                 {
                     HashMap lvt_20_1_ = Maps.newHashMap();
-                    map.forEach((p_229341_5_, p_229341_6_) ->
+                    map.forEach((p_lambda$loadBlockstate$25_5_, p_lambda$loadBlockstate$25_6_) ->
                     {
-                        Pair<UnbakedModel, Supplier<ModelBakery.ModelGroupKey>> pair2 = map1.get(p_229341_6_);
+                        Pair<UnbakedModel, Supplier<ModelBakery.ModelGroupKey>> pair2 = map1.get(p_lambda$loadBlockstate$25_6_);
 
                         if (pair2 == null)
                         {
-                            LOGGER.warn("Exception loading blockstate definition: '{}' missing model for variant: '{}'", resourcelocation1, p_229341_5_);
+                            LOGGER.warn("Exception loading blockstate definition: '{}' missing model for variant: '{}'", resourcelocation1, p_lambda$loadBlockstate$25_5_);
                             pair2 = pair;
                         }
 
-                        this.cacheAndQueueDependencies(p_229341_5_, pair2.getFirst());
+                        this.cacheAndQueueDependencies(p_lambda$loadBlockstate$25_5_, pair2.getFirst());
 
                         try {
                             ModelBakery.ModelGroupKey modelbakery$modelgroupkey1 = pair2.getSecond().get();
-                            lvt_20_1_.computeIfAbsent(modelbakery$modelgroupkey1, (p_229334_0_) -> {
+                            lvt_20_1_.computeIfAbsent(modelbakery$modelgroupkey1, (p_lambda$null$24_0_) -> {
                                 return Sets.newIdentityHashSet();
-                            }).add(p_229341_6_);
+                            }).add(p_lambda$loadBlockstate$25_6_);
                         }
-                        catch (Exception exception11)
+                        catch (Exception exception1)
                         {
-                            LOGGER.warn("Exception evaluating model definition: '{}'", p_229341_5_, exception11);
+                            LOGGER.warn("Exception evaluating model definition: '{}'", p_lambda$loadBlockstate$25_5_, exception1);
                         }
                     });
-                    lvt_20_1_.forEach((p_229335_1_, p_229335_2_) ->
+                    lvt_20_1_.forEach((p_lambda$loadBlockstate$26_1_, p_lambda$loadBlockstate$26_2_) ->
                     {
-                        Iterator<BlockState> iterator = p_229335_2_.iterator();
+                        Iterator<BlockState> iterator = ((Set)p_lambda$loadBlockstate$26_2_).iterator();
 
                         while (iterator.hasNext())
                         {
@@ -565,13 +559,25 @@
                             }
                         }
 
-                        if (p_229335_2_.size() > 1)
+                        if (((Set)p_lambda$loadBlockstate$26_2_).size() > 1)
                         {
-                            this.registerModelGroup(p_229335_2_);
+                            this.registerModelGroup((Set)p_lambda$loadBlockstate$26_2_);
                         }
                     });
                 }
             }
+
+            ResourceLocation resourcelocation = new ResourceLocation(p_119363_.getNamespace(), "item/" + p_119363_.getPath());
+            String s = p_119363_.getPath();
+
+            if (s.startsWith("optifine/") || s.startsWith("item/"))
+            {
+                resourcelocation = p_119363_;
+            }
+
+            BlockModel blockmodel = this.loadBlockModel(resourcelocation);
+            this.cacheAndQueueDependencies(modelresourcelocation, blockmodel);
+            this.unbakedCache.put(resourcelocation, blockmodel);
         }
     }
 
@@ -581,11 +587,11 @@
         this.loadingStack.addAll(p_119354_.getDependencies());
     }
 
-    private void addModelToCache(ResourceLocation locationIn)
+    private void addModelToCache(ResourceLocation p_addModelToCache_1_)
     {
-        UnbakedModel unbakedmodel = this.getModel(locationIn);
-        this.unbakedCache.put(locationIn, unbakedmodel);
-        this.topLevelModels.put(locationIn, unbakedmodel);
+        UnbakedModel unbakedmodel = this.getModel(p_addModelToCache_1_);
+        this.unbakedCache.put(p_addModelToCache_1_, unbakedmodel);
+        this.topLevelModels.put(p_addModelToCache_1_, unbakedmodel);
     }
 
     public void loadTopLevel(ModelResourceLocation p_119307_)
@@ -598,9 +604,9 @@
     private void registerModelGroup(Iterable<BlockState> p_119311_)
     {
         int i = this.nextModelGroup++;
-        p_119311_.forEach((p_229324_2_) ->
+        p_119311_.forEach((p_lambda$registerModelIds$27_2_) ->
         {
-            this.modelGroups.put(p_229324_2_, i);
+            this.modelGroups.put(p_lambda$registerModelIds$27_2_, i);
         });
     }
 
@@ -610,9 +616,9 @@
         return this.getBakedModel(p_119350_, p_119351_, this.atlasSet::getSprite);
     }
 
-    public BakedModel getBakedModel(ResourceLocation locationIn, ModelState transformIn, Function<Material, TextureAtlasSprite> textureGetter)
+    public BakedModel getBakedModel(ResourceLocation p_getBakedModel_1_, ModelState p_getBakedModel_2_, Function<Material, TextureAtlasSprite> p_getBakedModel_3_)
     {
-        Triple<ResourceLocation, Transformation, Boolean> triple = Triple.of(locationIn, transformIn.getRotation(), transformIn.isUvLocked());
+        Triple<ResourceLocation, Transformation, Boolean> triple = Triple.of(p_getBakedModel_1_, p_getBakedModel_2_.getRotation(), p_getBakedModel_2_.isUvLocked());
 
         if (this.bakedCache.containsKey(triple))
         {
@@ -624,7 +630,7 @@
         }
         else
         {
-            UnbakedModel unbakedmodel = this.getModel(locationIn);
+            UnbakedModel unbakedmodel = this.getModel(p_getBakedModel_1_);
 
             if (unbakedmodel instanceof BlockModel)
             {
@@ -634,18 +640,18 @@
                 {
                     if (Reflector.ForgeHooksClient.exists())
                     {
-                        return ITEM_MODEL_GENERATOR.generateBlockModel(textureGetter, blockmodel).bake(this, blockmodel, textureGetter, transformIn, locationIn, false);
+                        return ITEM_MODEL_GENERATOR.generateBlockModel(p_getBakedModel_3_, blockmodel).bake(this, blockmodel, p_getBakedModel_3_, p_getBakedModel_2_, p_getBakedModel_1_, false);
                     }
 
-                    return ITEM_MODEL_GENERATOR.generateBlockModel(this.atlasSet::getSprite, blockmodel).bake(this, blockmodel, this.atlasSet::getSprite, transformIn, locationIn, false);
+                    return ITEM_MODEL_GENERATOR.generateBlockModel(this.atlasSet::getSprite, blockmodel).bake(this, blockmodel, this.atlasSet::getSprite, p_getBakedModel_2_, p_getBakedModel_1_, false);
                 }
             }
 
-            BakedModel bakedmodel = unbakedmodel.bake(this, this.atlasSet::getSprite, transformIn, locationIn);
+            BakedModel bakedmodel = unbakedmodel.bake(this, this.atlasSet::getSprite, p_getBakedModel_2_, p_getBakedModel_1_);
 
             if (Reflector.ForgeHooksClient.exists())
             {
-                bakedmodel = unbakedmodel.bake(this, textureGetter, transformIn, locationIn);
+                bakedmodel = unbakedmodel.bake(this, p_getBakedModel_3_, p_getBakedModel_2_, p_getBakedModel_1_);
             }
 
             this.bakedCache.put(triple, bakedmodel);
@@ -657,47 +663,47 @@
     {
         Reader reader = null;
         Resource resource = null;
-        BlockModel basePath;
+        BlockModel blockmodel;
 
         try
         {
             String s = p_119365_.getPath();
             ResourceLocation resourcelocation = p_119365_;
 
-            if ("builtin/generated".equals(s))
-            {
-                return GENERATION_MARKER;
-            }
-
-            if (!"builtin/entity".equals(s))
+            if (!"builtin/generated".equals(s))
             {
-                if (s.startsWith("builtin/"))
+                if (!"builtin/entity".equals(s))
                 {
-                    String s2 = s.substring("builtin/".length());
-                    String s1 = BUILTIN_MODELS.get(s2);
+                    if (s.startsWith("builtin/"))
+                    {
+                        String s2 = s.substring("builtin/".length());
+                        String s1 = BUILTIN_MODELS.get(s2);
 
-                    if (s1 == null)
+                        if (s1 == null)
+                        {
+                            throw new FileNotFoundException(p_119365_.toString());
+                        }
+
+                        reader = new StringReader(s1);
+                    }
+                    else
                     {
-                        throw new FileNotFoundException(p_119365_.toString());
+                        resourcelocation = this.getModelLocation(p_119365_);
+                        resource = this.resourceManager.getResource(resourcelocation);
+                        reader = new InputStreamReader(resource.getInputStream(), StandardCharsets.UTF_8);
                     }
 
-                    reader = new StringReader(s1);
-                }
-                else
-                {
-                    resourcelocation = this.getModelLocation(p_119365_);
-                    resource = this.resourceManager.getResource(resourcelocation);
-                    reader = new InputStreamReader(resource.getInputStream(), StandardCharsets.UTF_8);
+                    blockmodel = BlockModel.fromStream(reader);
+                    blockmodel.name = p_119365_.toString();
+                    String s3 = TextureUtils.getBasePath(resourcelocation.getPath());
+                    fixModelLocations(blockmodel, s3);
+                    return blockmodel;
                 }
 
-                BlockModel blockmodel = BlockModel.fromStream(reader);
-                blockmodel.name = p_119365_.toString();
-                String s3 = TextureUtils.getBasePath(resourcelocation.getPath());
-                fixModelLocations(blockmodel, s3);
-                return blockmodel;
+                return BLOCK_ENTITY_MARKER;
             }
 
-            basePath = BLOCK_ENTITY_MARKER;
+            blockmodel = GENERATION_MARKER;
         }
         finally
         {
@@ -705,7 +711,7 @@
             IOUtils.closeQuietly((Closeable)resource);
         }
 
-        return basePath;
+        return blockmodel;
     }
 
     public Map<ResourceLocation, BakedModel> getBakedTopLevelModels()
@@ -718,37 +724,37 @@
         return this.modelGroups;
     }
 
-    private ResourceLocation getModelLocation(ResourceLocation location)
+    private ResourceLocation getModelLocation(ResourceLocation p_getModelLocation_1_)
     {
-        String s = location.getPath();
+        String s = p_getModelLocation_1_.getPath();
 
         if (s.startsWith("optifine/"))
         {
             if (!s.endsWith(".json"))
             {
-                location = new ResourceLocation(location.getNamespace(), s + ".json");
+                p_getModelLocation_1_ = new ResourceLocation(p_getModelLocation_1_.getNamespace(), s + ".json");
             }
 
-            return location;
+            return p_getModelLocation_1_;
         }
         else
         {
-            return new ResourceLocation(location.getNamespace(), "models/" + location.getPath() + ".json");
+            return new ResourceLocation(p_getModelLocation_1_.getNamespace(), "models/" + p_getModelLocation_1_.getPath() + ".json");
         }
     }
 
-    public static void fixModelLocations(BlockModel modelBlock, String basePath)
+    public static void fixModelLocations(BlockModel p_fixModelLocations_0_, String p_fixModelLocations_1_)
     {
-        ResourceLocation resourcelocation = fixModelLocation(modelBlock.parentLocation, basePath);
+        ResourceLocation resourcelocation = fixModelLocation(p_fixModelLocations_0_.parentLocation, p_fixModelLocations_1_);
 
-        if (resourcelocation != modelBlock.parentLocation)
+        if (resourcelocation != p_fixModelLocations_0_.parentLocation)
         {
-            modelBlock.parentLocation = resourcelocation;
+            p_fixModelLocations_0_.parentLocation = resourcelocation;
         }
 
-        if (modelBlock.textureMap != null)
+        if (p_fixModelLocations_0_.textureMap != null)
         {
-            for (Entry<String, Either<Material, String>> entry : modelBlock.textureMap.entrySet())
+            for (Entry<String, Either<Material, String>> entry : p_fixModelLocations_0_.textureMap.entrySet())
             {
                 Either<Material, String> either = entry.getValue();
                 Optional<Material> optional = either.left();
@@ -758,7 +764,7 @@
                     Material material = optional.get();
                     ResourceLocation resourcelocation1 = material.texture();
                     String s = resourcelocation1.getPath();
-                    String s1 = fixResourcePath(s, basePath);
+                    String s1 = fixResourcePath(s, p_fixModelLocations_1_);
 
                     if (!s1.equals(s))
                     {
@@ -772,38 +778,38 @@
         }
     }
 
-    public static ResourceLocation fixModelLocation(ResourceLocation loc, String basePath)
+    public static ResourceLocation fixModelLocation(ResourceLocation p_fixModelLocation_0_, String p_fixModelLocation_1_)
     {
-        if (loc != null && basePath != null)
+        if (p_fixModelLocation_0_ != null && p_fixModelLocation_1_ != null)
         {
-            if (!loc.getNamespace().equals("minecraft"))
+            if (!p_fixModelLocation_0_.getNamespace().equals("minecraft"))
             {
-                return loc;
+                return p_fixModelLocation_0_;
             }
             else
             {
-                String s = loc.getPath();
-                String s1 = fixResourcePath(s, basePath);
+                String s = p_fixModelLocation_0_.getPath();
+                String s1 = fixResourcePath(s, p_fixModelLocation_1_);
 
                 if (s1 != s)
                 {
-                    loc = new ResourceLocation(loc.getNamespace(), s1);
+                    p_fixModelLocation_0_ = new ResourceLocation(p_fixModelLocation_0_.getNamespace(), s1);
                 }
 
-                return loc;
+                return p_fixModelLocation_0_;
             }
         }
         else
         {
-            return loc;
+            return p_fixModelLocation_0_;
         }
     }
 
-    private static String fixResourcePath(String path, String basePath)
+    private static String fixResourcePath(String p_fixResourcePath_0_, String p_fixResourcePath_1_)
     {
-        path = TextureUtils.fixResourcePath(path, basePath);
-        path = StrUtils.removeSuffix(path, ".json");
-        return StrUtils.removeSuffix(path, ".png");
+        p_fixResourcePath_0_ = TextureUtils.fixResourcePath(p_fixResourcePath_0_, p_fixResourcePath_1_);
+        p_fixResourcePath_0_ = StrUtils.removeSuffix(p_fixResourcePath_0_, ".json");
+        return StrUtils.removeSuffix(p_fixResourcePath_0_, ".png");
     }
 
     public Set<ResourceLocation> getSpecialModels()
@@ -860,9 +866,9 @@
         public static ModelBakery.ModelGroupKey create(BlockState p_119380_, MultiPart p_119381_, Collection < Property<? >> p_119382_)
         {
             StateDefinition<Block, BlockState> statedefinition = p_119380_.getBlock().getStateDefinition();
-            List<UnbakedModel> list = p_119381_.getSelectors().stream().filter((p_225338_2_) ->
+            List<UnbakedModel> list = p_119381_.getSelectors().stream().filter((p_lambda$makeWrapper$0_2_) ->
             {
-                return p_225338_2_.getPredicate(statedefinition).test(p_119380_);
+                return p_lambda$makeWrapper$0_2_.getPredicate(statedefinition).test(p_119380_);
             }).map(Selector::getVariant).collect(ImmutableList.toImmutableList());
             List<Object> list1 = getColoringValues(p_119380_, p_119382_);
             return new ModelBakery.ModelGroupKey(list, list1);
