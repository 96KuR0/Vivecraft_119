--- a/net/minecraft/world/level/levelgen/feature/treedecorators/AlterGroundDecorator.java
+++ b/net/minecraft/world/level/levelgen/feature/treedecorators/AlterGroundDecorator.java
@@ -1,91 +1,250 @@
-package net.minecraft.world.level.levelgen.feature.treedecorators;
+package com.mojang.blaze3d.platform;
 
-import com.mojang.serialization.Codec;
+import com.google.common.base.Joiner;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.mojang.blaze3d.systems.RenderSystem;
+import com.mojang.blaze3d.vertex.BufferBuilder;
+import com.mojang.blaze3d.vertex.DefaultVertexFormat;
+import com.mojang.blaze3d.vertex.Tesselator;
 import java.util.List;
-import java.util.Random;
-import java.util.Set;
-import net.minecraft.core.BlockPos;
-import net.minecraft.world.level.LevelSimulatedRW;
-import net.minecraft.world.level.WorldGenLevel;
-import net.minecraft.world.level.levelgen.feature.Feature;
-import net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider;
-import net.minecraft.world.level.levelgen.structure.BoundingBox;
+import java.util.Map;
+import java.util.function.Consumer;
+import java.util.function.LongSupplier;
+import java.util.function.Supplier;
+import net.optifine.Config;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.lwjgl.Version;
+import org.lwjgl.glfw.GLFW;
+import org.lwjgl.glfw.GLFWErrorCallback;
+import org.lwjgl.glfw.GLFWErrorCallbackI;
+import org.lwjgl.glfw.GLFWVidMode;
+import org.lwjgl.opengl.GL;
+import org.lwjgl.opengl.GL11;
+import org.lwjgl.opengl.GLCapabilities;
+import oshi.SystemInfo;
+import oshi.hardware.Processor;
 
-public class AlterGroundDecorator extends TreeDecorator
+public class GLX
 {
-    public static final Codec<AlterGroundDecorator> CODEC = BlockStateProvider.CODEC.fieldOf("provider").xmap(AlterGroundDecorator::new, (p_69327_) ->
+    private static final Logger LOGGER = LogManager.getLogger();
+    private static String capsString = "";
+    private static String cpuInfo;
+    private static final Map<Integer, String> LOOKUP_MAP = make(Maps.newHashMap(), (p_229878_0_) ->
+    {
+        p_229878_0_.put(0, "No error");
+        p_229878_0_.put(1280, "Enum parameter is invalid for this function");
+        p_229878_0_.put(1281, "Parameter is invalid for this function");
+        p_229878_0_.put(1282, "Current state is invalid for this function");
+        p_229878_0_.put(1283, "Stack overflow");
+        p_229878_0_.put(1284, "Stack underflow");
+        p_229878_0_.put(1285, "Out of memory");
+        p_229878_0_.put(1286, "Operation on incomplete framebuffer");
+        p_229878_0_.put(1286, "Operation on incomplete framebuffer");
+    });
+
+    public static String getOpenGLVersionString()
     {
-        return p_69327_.provider;
-    }).codec();
-    private final BlockStateProvider provider;
+        RenderSystem.assertThread(RenderSystem::isOnRenderThread);
+        return GLFW.glfwGetCurrentContext() == 0L ? "NO CONTEXT" : GlStateManager._getString(7937) + " GL version " + GlStateManager._getString(7938) + ", " + GlStateManager._getString(7936);
+    }
 
-    public AlterGroundDecorator(BlockStateProvider p_69306_)
+    public static int _getRefreshRate(Window p_69342_)
     {
-        this.provider = p_69306_;
+        RenderSystem.assertThread(RenderSystem::isOnRenderThread);
+        long j = GLFW.glfwGetWindowMonitor(p_69342_.getWindow());
+
+        if (j == 0L)
+        {
+            j = GLFW.glfwGetPrimaryMonitor();
+        }
+
+        GLFWVidMode glfwvidmode1 = j == 0L ? null : GLFW.glfwGetVideoMode(j);
+        return glfwvidmode1 == null ? 0 : glfwvidmode1.refreshRate();
     }
 
-    protected TreeDecoratorType<?> type()
+    public static String _getLWJGLVersion()
     {
-        return TreeDecoratorType.ALTER_GROUND;
+        RenderSystem.assertThread(RenderSystem::isInInitPhase);
+        return Version.getVersion();
     }
 
-    public void place(WorldGenLevel p_69320_, Random p_69321_, List<BlockPos> p_69322_, List<BlockPos> p_69323_, Set<BlockPos> p_69324_, BoundingBox p_69325_)
+    public static LongSupplier _initGlfw()
     {
-        int i = p_69322_.get(0).getY();
-        p_69322_.stream().filter((p_69310_) ->
+        RenderSystem.assertThread(RenderSystem::isInInitPhase);
+        Window.checkGlfwError((p_229879_0_, p_229879_1_) ->
+        {
+            throw new IllegalStateException(String.format("GLFW error before init: [0x%X]%s", p_229879_0_, p_229879_1_));
+        });
+        List<String> list1 = Lists.newArrayList();
+        GLFWErrorCallback glfwerrorcallback1 = GLFW.glfwSetErrorCallback((p_229880_1_, p_229880_2_) ->
+        {
+            list1.add(String.format("GLFW error during init: [0x%X]%s", p_229880_1_, p_229880_2_));
+        });
+
+        if (!GLFW.glfwInit())
         {
-            return p_69310_.getY() == i;
-        }).forEach((p_69318_) ->
+            throw new IllegalStateException("Failed to initialize GLFW, errors: " + Joiner.on(",").join(list1));
+        }
+        else
         {
-            this.placeCircle(p_69320_, p_69321_, p_69318_.west().north());
-            this.placeCircle(p_69320_, p_69321_, p_69318_.east(2).north());
-            this.placeCircle(p_69320_, p_69321_, p_69318_.west().south(2));
-            this.placeCircle(p_69320_, p_69321_, p_69318_.east(2).south(2));
+            LongSupplier longsupplier1 = () ->
+            {
+                return (long)(GLFW.glfwGetTime() * 1.0E9D);
+            };
 
-            for (int j = 0; j < 5; ++j)
+            for (String s1 : list1)
             {
-                int k = p_69321_.nextInt(64);
-                int l = k % 8;
-                int i1 = k / 8;
-
-                if (l == 0 || l == 7 || i1 == 0 || i1 == 7)
-                {
-                    this.placeCircle(p_69320_, p_69321_, p_69318_.offset(-3 + l, 0, -3 + i1));
-                }
+                LOGGER.error("GLFW error collected during initialization: {}", (Object)s1);
             }
-        });
+
+            RenderSystem.setErrorCallback(glfwerrorcallback1);
+            return longsupplier1;
+        }
     }
 
-    private void placeCircle(LevelSimulatedRW p_69312_, Random p_69313_, BlockPos p_69314_)
+    public static void _setGlfwErrorCallback(GLFWErrorCallbackI p_69353_)
     {
-        for (int i = -2; i <= 2; ++i)
+        RenderSystem.assertThread(RenderSystem::isInInitPhase);
+        GLFWErrorCallback glfwerrorcallback1 = GLFW.glfwSetErrorCallback(p_69353_);
+
+        if (glfwerrorcallback1 != null)
         {
-            for (int j = -2; j <= 2; ++j)
-            {
-                if (Math.abs(i) != 2 || Math.abs(j) != 2)
-                {
-                    this.placeBlockAt(p_69312_, p_69313_, p_69314_.offset(i, 0, j));
-                }
-            }
+            glfwerrorcallback1.free();
         }
     }
 
-    private void placeBlockAt(LevelSimulatedRW p_69329_, Random p_69330_, BlockPos p_69331_)
+    public static boolean _shouldClose(Window p_69356_)
     {
-        for (int i = 2; i >= -3; --i)
-        {
-            BlockPos blockpos = p_69331_.above(i);
+        return GLFW.glfwWindowShouldClose(p_69356_.getWindow());
+    }
+
+    public static void _setupNvFogDistance()
+    {
+        RenderSystem.assertThread(RenderSystem::isOnRenderThread);
 
-            if (Feature.isGrassOrDirt(p_69329_, blockpos))
+        if (GL.getCapabilities().GL_NV_fog_distance)
+        {
+            if (Config.isFogFancy())
             {
-                p_69329_.setBlock(blockpos, this.provider.getState(p_69330_, p_69331_), 19);
-                break;
+                GlStateManager._fogi(34138, 34139);
             }
 
-            if (!Feature.isAir(p_69329_, blockpos) && i < 0)
+            if (Config.isFogFast())
             {
-                break;
+                GlStateManager._fogi(34138, 34140);
             }
         }
     }
+
+    public static void _init(int p_69344_, boolean p_69345_)
+    {
+        RenderSystem.assertThread(RenderSystem::isInInitPhase);
+        GLCapabilities glcapabilities1 = GL.getCapabilities();
+        capsString = "Using framebuffer using " + GlStateManager._init_fbo(glcapabilities1);
+
+        try
+        {
+            Processor[] aprocessor1 = (new SystemInfo()).getHardware().getProcessors();
+            cpuInfo = String.format("%dx %s", aprocessor1.length, aprocessor1[0]).replaceAll("\\s+", " ");
+        }
+        catch (Throwable throwable1)
+        {
+        }
+
+        GlDebug.enableDebugCallback(p_69344_, p_69345_);
+    }
+
+    public static String _getCapsString()
+    {
+        return capsString;
+    }
+
+    public static String _getCpuInfo()
+    {
+        return cpuInfo == null ? "<unknown>" : cpuInfo;
+    }
+
+    public static void _renderCrosshair(int p_69348_, boolean p_69349_, boolean p_69350_, boolean p_69351_)
+    {
+        RenderSystem.assertThread(RenderSystem::isOnRenderThread);
+        GlStateManager._disableTexture();
+        GlStateManager._depthMask(false);
+        Tesselator tesselator1 = RenderSystem.renderThreadTesselator();
+        BufferBuilder bufferbuilder1 = tesselator1.getBuilder();
+        GL11.glLineWidth(4.0F);
+        bufferbuilder1.begin(1, DefaultVertexFormat.POSITION_COLOR);
+
+        if (p_69349_)
+        {
+            bufferbuilder1.vertex(0.0D, 0.0D, 0.0D).color(0, 0, 0, 255).endVertex();
+            bufferbuilder1.vertex((double)p_69348_, 0.0D, 0.0D).color(0, 0, 0, 255).endVertex();
+        }
+
+        if (p_69350_)
+        {
+            bufferbuilder1.vertex(0.0D, 0.0D, 0.0D).color(0, 0, 0, 255).endVertex();
+            bufferbuilder1.vertex(0.0D, (double)p_69348_, 0.0D).color(0, 0, 0, 255).endVertex();
+        }
+
+        if (p_69351_)
+        {
+            bufferbuilder1.vertex(0.0D, 0.0D, 0.0D).color(0, 0, 0, 255).endVertex();
+            bufferbuilder1.vertex(0.0D, 0.0D, (double)p_69348_).color(0, 0, 0, 255).endVertex();
+        }
+
+        tesselator1.end();
+        GL11.glLineWidth(2.0F);
+        bufferbuilder1.begin(1, DefaultVertexFormat.POSITION_COLOR);
+
+        if (p_69349_)
+        {
+            bufferbuilder1.vertex(0.0D, 0.0D, 0.0D).color(255, 0, 0, 255).endVertex();
+            bufferbuilder1.vertex((double)p_69348_, 0.0D, 0.0D).color(255, 0, 0, 255).endVertex();
+        }
+
+        if (p_69350_)
+        {
+            bufferbuilder1.vertex(0.0D, 0.0D, 0.0D).color(0, 255, 0, 255).endVertex();
+            bufferbuilder1.vertex(0.0D, (double)p_69348_, 0.0D).color(0, 255, 0, 255).endVertex();
+        }
+
+        if (p_69351_)
+        {
+            bufferbuilder1.vertex(0.0D, 0.0D, 0.0D).color(127, 127, 255, 255).endVertex();
+            bufferbuilder1.vertex(0.0D, 0.0D, (double)p_69348_).color(127, 127, 255, 255).endVertex();
+        }
+
+        tesselator1.end();
+        GL11.glLineWidth(1.0F);
+        GlStateManager._depthMask(true);
+        GlStateManager._enableTexture();
+    }
+
+    public static String getErrorString(int p_69358_)
+    {
+        return LOOKUP_MAP.get(p_69358_);
+    }
+
+    public static <T> T make(Supplier<T> p_69374_)
+    {
+        return p_69374_.get();
+    }
+
+    public static <T> T make(T p_69371_, Consumer<T> p_69372_)
+    {
+        p_69372_.accept(p_69371_);
+        return p_69371_;
+    }
+
+    public static boolean isUsingFBOs()
+    {
+        return !Config.isAntialiasing();
+    }
+
+    public static boolean useVbo()
+    {
+        return true;
+    }
 }
