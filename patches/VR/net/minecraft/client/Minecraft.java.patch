--- a/net/minecraft/client/Minecraft.java
+++ b/net/minecraft/client/Minecraft.java
@@ -1,5 +1,88 @@
 package net.minecraft.client;
 
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.UncheckedIOException;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.net.Proxy;
+import java.net.SocketAddress;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.nio.Buffer;
+import java.nio.ByteBuffer;
+import java.nio.FloatBuffer;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.text.DecimalFormat;
+import java.text.DecimalFormatSymbols;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Deque;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Locale;
+import java.util.MissingResourceException;
+import java.util.Optional;
+import java.util.Queue;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import java.util.stream.Stream;
+
+import javax.annotation.Nullable;
+
+import org.apache.commons.io.FileUtils;
+import org.lwjgl.opengl.ARBShaderObjects;
+import org.lwjgl.util.tinyfd.TinyFileDialogs;
+import org.slf4j.Logger;
+import org.vivecraft.api.ErrorHelper;
+import org.vivecraft.api.NetworkHelper;
+import org.vivecraft.gameplay.VRPlayer;
+import org.vivecraft.gameplay.screenhandlers.GuiHandler;
+import org.vivecraft.gameplay.screenhandlers.RadialHandler;
+import org.vivecraft.gameplay.trackers.BackpackTracker;
+import org.vivecraft.gameplay.trackers.BowTracker;
+import org.vivecraft.gameplay.trackers.CameraTracker;
+import org.vivecraft.gameplay.trackers.ClimbTracker;
+import org.vivecraft.gameplay.trackers.CrawlTracker;
+import org.vivecraft.gameplay.trackers.EatingTracker;
+import org.vivecraft.gameplay.trackers.HorseTracker;
+import org.vivecraft.gameplay.trackers.InteractTracker;
+import org.vivecraft.gameplay.trackers.JumpTracker;
+import org.vivecraft.gameplay.trackers.RowTracker;
+import org.vivecraft.gameplay.trackers.RunTracker;
+import org.vivecraft.gameplay.trackers.SneakTracker;
+import org.vivecraft.gameplay.trackers.SwimTracker;
+import org.vivecraft.gameplay.trackers.SwingTracker;
+import org.vivecraft.gameplay.trackers.TeleportTracker;
+import org.vivecraft.gameplay.trackers.TelescopeTracker;
+import org.vivecraft.gameplay.trackers.VehicleTracker;
+import org.vivecraft.menuworlds.MenuWorldRenderer;
+import org.vivecraft.provider.MCVR;
+import org.vivecraft.provider.VRRenderer;
+import org.vivecraft.provider.openvr_jna.MCOpenVR;
+import org.vivecraft.provider.openvr_jna.OpenVRStereoRenderer;
+import org.vivecraft.provider.openvr_jna.VRInputAction;
+import org.vivecraft.provider.ovr_lwjgl.MC_OVR;
+import org.vivecraft.provider.ovr_lwjgl.OVR_StereoRenderer;
+import org.vivecraft.render.PlayerModelController;
+import org.vivecraft.render.RenderConfigException;
+import org.vivecraft.render.RenderPass;
+import org.vivecraft.render.VRFirstPersonArmSwing;
+import org.vivecraft.render.VRShaders;
+import org.vivecraft.settings.VRHotkeys;
+import org.vivecraft.settings.VRSettings;
+import org.vivecraft.utils.LangHelper;
+import org.vivecraft.utils.Utils;
+import org.vivecraft.utils.math.Vector3;
+
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Queues;
@@ -16,8 +99,10 @@
 import com.mojang.blaze3d.pipeline.TextureTarget;
 import com.mojang.blaze3d.platform.DisplayData;
 import com.mojang.blaze3d.platform.GlDebug;
+import com.mojang.blaze3d.platform.GlStateManager;
 import com.mojang.blaze3d.platform.GlUtil;
 import com.mojang.blaze3d.platform.MacosUtil;
+import com.mojang.blaze3d.platform.MemoryTracker;
 import com.mojang.blaze3d.platform.Window;
 import com.mojang.blaze3d.platform.WindowEventHandler;
 import com.mojang.blaze3d.systems.RenderSystem;
@@ -34,31 +119,7 @@
 import com.mojang.realmsclient.client.RealmsClient;
 import com.mojang.realmsclient.dto.RealmsServer;
 import com.mojang.realmsclient.gui.RealmsDataFetcher;
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.UncheckedIOException;
-import java.net.Proxy;
-import java.net.SocketAddress;
-import java.nio.ByteBuffer;
-import java.nio.file.Path;
-import java.nio.file.Paths;
-import java.text.DecimalFormat;
-import java.text.DecimalFormatSymbols;
-import java.util.Collections;
-import java.util.List;
-import java.util.Locale;
-import java.util.MissingResourceException;
-import java.util.Optional;
-import java.util.Queue;
-import java.util.UUID;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.atomic.AtomicReference;
-import java.util.function.Consumer;
-import java.util.function.Function;
-import java.util.function.Supplier;
-import java.util.stream.Stream;
-import javax.annotation.Nullable;
+
 import net.minecraft.ChatFormatting;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
@@ -99,6 +160,7 @@
 import net.minecraft.client.gui.screens.social.SocialInteractionsScreen;
 import net.minecraft.client.gui.screens.worldselection.WorldOpenFlows;
 import net.minecraft.client.main.GameConfig;
+import net.minecraft.client.main.Main;
 import net.minecraft.client.model.geom.EntityModelSet;
 import net.minecraft.client.multiplayer.ClientHandshakePacketListenerImpl;
 import net.minecraft.client.multiplayer.ClientLevel;
@@ -123,6 +185,7 @@
 import net.minecraft.client.renderer.block.BlockModelShaper;
 import net.minecraft.client.renderer.block.BlockRenderDispatcher;
 import net.minecraft.client.renderer.blockentity.BlockEntityRenderDispatcher;
+import net.minecraft.client.renderer.chunk.VisGraph;
 import net.minecraft.client.renderer.debug.DebugRenderer;
 import net.minecraft.client.renderer.entity.EntityRenderDispatcher;
 import net.minecraft.client.renderer.entity.EntityRenderers;
@@ -149,6 +212,7 @@
 import net.minecraft.client.searchtree.SearchTree;
 import net.minecraft.client.server.IntegratedServer;
 import net.minecraft.client.sounds.MusicManager;
+import net.minecraft.client.sounds.SoundEngine;
 import net.minecraft.client.sounds.SoundManager;
 import net.minecraft.client.tutorial.Tutorial;
 import net.minecraft.core.BlockPos;
@@ -229,6 +293,7 @@
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.biome.Biome;
 import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.RenderShape;
 import net.minecraft.world.level.block.entity.BlockEntity;
 import net.minecraft.world.level.block.entity.SkullBlockEntity;
@@ -237,14 +302,70 @@
 import net.minecraft.world.phys.BlockHitResult;
 import net.minecraft.world.phys.EntityHitResult;
 import net.minecraft.world.phys.HitResult;
-import org.apache.commons.io.FileUtils;
-import org.lwjgl.util.tinyfd.TinyFileDialogs;
-import org.slf4j.Logger;
+import net.minecraft.world.phys.Vec3;
+import net.minecraftforge.client.event.InputEvent.InteractionKeyMappingTriggered;
+import net.optifine.Config;
+import net.optifine.reflect.Reflector;
+import net.optifine.reflect.ReflectorForge;
+import net.optifine.shaders.Shaders;
 
-public class Minecraft extends ReentrantBlockableEventLoop<Runnable> implements WindowEventHandler
+public class Minecraft extends ReentrantBlockableEventLoop<Runnable> implements WindowEventHandler, net.minecraftforge.client.extensions.IForgeMinecraft
 {
     static Minecraft instance;
     private static final Logger LOGGER = LogUtils.getLogger();
+    public VRPlayer vrPlayer;
+    public MCVR vr;
+    public VRRenderer vrRenderer;
+    public BackpackTracker backpackTracker = new BackpackTracker(this);
+    public BowTracker bowTracker = new BowTracker(this);
+    public SwimTracker swimTracker = new SwimTracker(this);
+    public EatingTracker autoFood = new EatingTracker(this);
+    public JumpTracker jumpTracker = new JumpTracker(this);
+    public SneakTracker sneakTracker = new SneakTracker(this);
+    public ClimbTracker climbTracker = new ClimbTracker(this);
+    public RunTracker runTracker = new RunTracker(this);
+    public RowTracker rowTracker = new RowTracker(this);
+    public TeleportTracker teleportTracker = new TeleportTracker(this);
+    public SwingTracker swingTracker = new SwingTracker(this);
+    public HorseTracker horseTracker = new HorseTracker(this);
+    public VehicleTracker vehicleTracker = new VehicleTracker(this);
+    //public PhysicalGuiManager physicalGuiManager = new PhysicalGuiManager(this);
+    public InteractTracker interactTracker = new InteractTracker(this);
+    public CrawlTracker crawlTracker = new CrawlTracker(this);
+    public CameraTracker cameraTracker = new CameraTracker(this);
+    public ThreadGroup backgroundThreadGroup = new ThreadGroup("background");
+    public final float PIOVER180 = ((float)Math.PI / 180F);
+    public int lastShaderIndex = -1;
+    public Field fieldHwnd = null;
+    public Field fieldDisplay = null;
+    public Field fieldWindow = null;
+    public Field fieldResized = null;
+    public Method fieldResizedMethod = null;
+    public VRSettings vrSettings;
+    public long lastIntegratedServerLaunchCheck = 0L;
+    public boolean integratedServerLaunchInProgress = false;
+    public boolean grabScreenShot = false;
+    public boolean lastShowMouseNative = true;
+    public boolean enableWorldExport = false;
+    public SoundEngine sndManager = null;
+    public MenuWorldRenderer menuWorldRenderer;
+    private FloatBuffer matrixBuffer = MemoryTracker.create(16).asFloatBuffer();
+    private FloatBuffer matrixBuffer2 = MemoryTracker.create(16).asFloatBuffer();
+    private boolean firstInit = true;
+    public boolean showSplashScreen = true;
+    public long splashTimer1 = 0L;
+    public long splashTimer2 = 0L;
+    private RenderTarget splash;
+    private float splashFadeAlpha = 0.0F;
+    public Deque<Long> runTickTimeNanos = new ArrayDeque<>();
+    public long medianRunTickTimeNanos = 0L;
+    public long frameIndex = 0L;
+    public ErrorHelper errorHelper;
+    public RenderPass currentPass;
+    private boolean lastClick;
+    public boolean resourcePacksChanged;
+    public int tickCounter;
+    public final String minecriftVerString = "Vivecraft 1.19.2  jrbudda-VR-2-b7";
     public static final boolean ON_OSX = Util.getPlatform() == Util.OS.OSX;
     private static final int MAX_TICKS_PER_UPDATE = 10;
     public static final ResourceLocation DEFAULT_FONT = new ResourceLocation("default");
@@ -274,7 +395,7 @@
     public final DebugRenderer debugRenderer;
     private final AtomicReference<StoringChunkProgressListener> progressListener = new AtomicReference<>();
     public final Gui gui;
-    public final Options options;
+    public Options options;
     private final HotbarManager hotbarManager;
     public final MouseHandler mouseHandler;
     public final KeyboardHandler keyboardHandler;
@@ -294,7 +415,7 @@
     private final LanguageManager languageManager;
     private final BlockColors blockColors;
     private final ItemColors itemColors;
-    private final RenderTarget mainRenderTarget;
+    public RenderTarget mainRenderTarget;
     private final SoundManager soundManager;
     private final MusicManager musicManager;
     private final FontManager fontManager;
@@ -386,6 +507,14 @@
     private final ChatListener chatListener;
     private ReportingContext reportingContext;
     private String debugPath = "root";
+    private float fov = 1.0F;
+    public float watereffect;
+    public float portaleffect;
+    public float pumpkineffect;
+    long mirroNotifyStart;
+    String mirrorNotifyText;
+    boolean mirrorNotifyClear;
+    long mirroNotifyLen;
 
     public Minecraft(GameConfig pGameConfig)
     {
@@ -405,8 +534,6 @@
         this.userApiService = this.createUserApiService(this.authenticationService, pGameConfig);
         this.serviceSignatureValidator = SignatureValidator.from(this.authenticationService.getServicesKey());
         this.user = pGameConfig.user.user;
-        LOGGER.info("Setting user: {}", (Object)this.user.getName());
-        LOGGER.debug("(Session ID is {})", (Object)this.user.getSessionId());
         this.demo = pGameConfig.game.demo;
         this.allowsMultiplayer = !pGameConfig.game.disableMultiplayer;
         this.allowsChat = !pGameConfig.game.disableChat;
@@ -429,6 +556,23 @@
         KeybindResolver.setKeyResolver(KeyMapping::createNameSupplier);
         this.fixerUpper = DataFixers.getDataFixer();
         this.toast = new ToastComponent(this);
+        if (!Main.oculus)
+        {
+            this.vr = new MCOpenVR(this);
+        }
+        else
+        {
+            this.vr = new MC_OVR(this);
+        }
+
+        VRSettings.initSettings(this, this.gameDirectory);
+
+        if (!this.vrSettings.badStereoProviderPluginID.isEmpty())
+        {
+            this.vrSettings.stereoProviderPluginID = this.vrSettings.badStereoProviderPluginID;
+            this.vrSettings.badStereoProviderPluginID = "";
+            this.vrSettings.saveOptions();
+        }
         this.gameThread = Thread.currentThread();
         this.options = new Options(this, this.gameDirectory);
         this.running = true;
@@ -472,14 +616,19 @@
 
         this.window.setFramerateLimit(this.options.framerateLimit().get());
         this.mouseHandler = new MouseHandler(this);
-        this.mouseHandler.setup(this.window.getWindow());
+        //Forge
+        //this.mouseHandler.setup(this.window.getWindow());
+        //
         this.keyboardHandler = new KeyboardHandler(this);
         this.keyboardHandler.setup(this.window.getWindow());
         RenderSystem.initRenderer(this.options.glDebugVerbosity, false);
-        this.mainRenderTarget = new MainTarget(this.window.getWidth(), this.window.getHeight());
+        this.mainRenderTarget = new MainTarget(this.window.getScreenWidth(), this.window.getScreenHeight());
         this.mainRenderTarget.setClearColor(0.0F, 0.0F, 0.0F, 0.0F);
         this.mainRenderTarget.clear(ON_OSX);
         this.resourceManager = new ReloadableResourceManager(PackType.CLIENT_RESOURCES);
+        //Forge
+        Reflector.call(Reflector.ClientModLoader_begin, this, this.resourcePackRepository, this.resourceManager, this.clientPackSource);
+        //
         this.resourcePackRepository.reload();
         this.options.loadSelectedResourcePacks(this.resourcePackRepository);
         this.languageManager = new LanguageManager(this.options.languageCode);
@@ -498,6 +647,16 @@
         this.fontFilterFishy = this.fontManager.createFontFilterFishy();
         this.resourceManager.registerReloadListener(this.fontManager.getReloadListener());
         this.selectMainFont(this.isEnforceUnicode());
+        /** MINECRIFT */
+        try
+        {
+            this.initMinecrift();
+        }
+        catch (Exception exception)
+        {
+            exception.printStackTrace();
+        }
+        /** END MINECRIFT */
         this.resourceManager.registerReloadListener(new GrassColorReloadListener());
         this.resourceManager.registerReloadListener(new FoliageColorReloadListener());
         this.window.setErrorSection("Startup");
@@ -524,10 +683,18 @@
         this.gameRenderer = new GameRenderer(this, this.entityRenderDispatcher.getItemInHandRenderer(), this.resourceManager, this.renderBuffers);
         this.resourceManager.registerReloadListener(this.gameRenderer);
         this.levelRenderer = new LevelRenderer(this, this.entityRenderDispatcher, this.blockEntityRenderDispatcher, this.renderBuffers);
+        //Forge
+        //net.minecraftforge.fml.ModLoader.get().postEvent(new net.minecraftforge.client.event.RenderLevelStageEvent.RegisterStageEvent());
+        Reflector.call(Reflector.call(Reflector.fml_ModLoader_get), Reflector.fml_ModLoader_postEvent, Reflector.newInstance(Reflector.RegisterStageEvent_Constructor));
+        //
         this.resourceManager.registerReloadListener(this.levelRenderer);
         this.createSearchTrees();
         this.resourceManager.registerReloadListener(this.searchRegistry);
         this.particleEngine = new ParticleEngine(this.level, this.textureManager);
+        //Forge
+        //net.minecraftforge.client.ForgeHooksClient.onRegisterParticleProviders(particleEngine);
+        Reflector.call(Reflector.ForgeHooksClient_onRegisterParticleProviders, particleEngine);
+        //
         this.resourceManager.registerReloadListener(this.particleEngine);
         this.paintingTextures = new PaintingTextureManager(this.textureManager);
         this.resourceManager.registerReloadListener(this.paintingTextures);
@@ -536,7 +703,16 @@
         this.gpuWarnlistManager = new GpuWarnlistManager();
         this.resourceManager.registerReloadListener(this.gpuWarnlistManager);
         this.resourceManager.registerReloadListener(this.regionalCompliancies);
-        this.gui = new Gui(this, this.itemRenderer);
+        
+        if (Reflector.ForgeIngameGui_Constructor.exists())
+        {
+            this.gui = (Gui)Reflector.newInstance(Reflector.ForgeIngameGui_Constructor, this);
+        }
+        else
+        {
+        	this.gui = new Gui(this, this.itemRenderer);
+        }
+        this.mouseHandler.setup(this.window.getWindow()); //Forge: Moved below ingameGUI setting to prevent NPEs in handeler.
         this.debugRenderer = new DebugRenderer(this);
         this.realmsDataFetcher = new RealmsDataFetcher(RealmsClient.create(this));
         RenderSystem.setErrorCallback(this::onFullscreenError);
@@ -562,10 +738,46 @@
             TinyFileDialogs.tinyfd_messageBox("Minecraft", stringbuilder.toString(), "ok", "error", false);
         }
 
+        //Forge
+        Reflector.call(Reflector.call(Reflector.fml_ModLoader_get), Reflector.fml_ModLoader_postEvent, Reflector.newInstance(Reflector.RegisterClientReloadListenersEvent_Constructor,this.resourceManager));
+        Reflector.call(Reflector.call(Reflector.fml_ModLoader_get), Reflector.fml_ModLoader_postEvent, Reflector.newInstance(Reflector.EntityRenderersEvent_RegisterLayerDefinitions_Constructor));
+        Reflector.call(Reflector.call(Reflector.fml_ModLoader_get), Reflector.fml_ModLoader_postEvent, Reflector.newInstance(Reflector.EntityRenderersEvent_RegisterRenderers_Constructor));
+        Reflector.call(Reflector.TextureAtlasSpriteLoaderManager_init);
+        Reflector.call(Reflector.ClientTooltipComponentManager_init);
+        Reflector.call(Reflector.EntitySpectatorShaderManager_init);
+        Reflector.call(Reflector.ForgeHooksClient_onRegisterKeyMappings, this.options);
+        Reflector.call(Reflector.RecipeBookManager_init);
+        Reflector.call(Reflector.GuiOverlayManager_init);
+        Reflector.call(Reflector.DimensionSpecialEffectsManager_init);
+        Reflector.call(Reflector.NamedRenderTypeManager_init);
+        //new in .2
+        Reflector.call(Reflector.ColorResolverManager_init);
+        Reflector.call(Reflector.ItemDecoratorHandler_init);
+        //
+        //1.19
+//        net.minecraftforge.gametest.ForgeGameTestHooks.registerGametests();
+//        net.minecraftforge.fml.ModLoader.get().postEvent(new net.minecraftforge.client.event.RegisterClientReloadListenersEvent(this.resourceManager));
+//        net.minecraftforge.fml.ModLoader.get().postEvent(new net.minecraftforge.client.event.EntityRenderersEvent.RegisterLayerDefinitions());
+//        net.minecraftforge.fml.ModLoader.get().postEvent(new net.minecraftforge.client.event.EntityRenderersEvent.RegisterRenderers());
+//        net.minecraftforge.client.textures.TextureAtlasSpriteLoaderManager.init();
+//        net.minecraftforge.client.gui.ClientTooltipComponentManager.init();
+//        net.minecraftforge.client.EntitySpectatorShaderManager.init();
+//        net.minecraftforge.client.ForgeHooksClient.onRegisterKeyMappings(options);
+//        net.minecraftforge.client.RecipeBookManager.init();
+//        net.minecraftforge.client.gui.overlay.GuiOverlayManager.init();
+//        net.minecraftforge.client.DimensionSpecialEffectsManager.init();
+//        net.minecraftforge.client.NamedRenderTypeManager.init();
+
+        
         this.window.updateVsync(this.options.enableVsync().get());
         this.window.updateRawMouseInput(this.options.rawMouseInput().get());
         this.window.setDefaultErrorCallback();
         this.resizeDisplay();
+        //Vivecraft
+        this.menuWorldRenderer = new MenuWorldRenderer();
+        this.vrSettings.firstRun = false;
+        this.vrSettings.saveOptions();
+        //
         this.gameRenderer.preloadUiShader(this.getClientPackSource().getVanillaPack().asProvider());
         this.profileKeyPairManager = new ProfileKeyPairManager(this.userApiService, this.user.getGameProfile().getId(), this.gameDirectory.toPath());
         this.realms32BitWarningStatus = new Realms32BitWarningStatus(this);
@@ -579,6 +791,11 @@
         ReloadInstance reloadinstance = this.resourceManager.createReload(Util.backgroundExecutor(), this, RESOURCE_RELOAD_INITIAL_TASK, list);
         this.setOverlay(new LoadingOverlay(this, reloadinstance, (p_210745_) ->
         {
+            if (this.vrRenderer.isInitialized())
+            {
+                this.menuWorldRenderer.init();
+            }
+            this.vr.postinit();
             Util.ifElse(p_210745_, this::rollbackResourcePacks, () -> {
                 if (SharedConstants.IS_RUNNING_IN_IDE)
                 {
@@ -586,32 +803,36 @@
                 }
 
                 this.reloadStateTracker.finishReload();
+                 //Forge
+                 if (!Reflector.callBoolean(Reflector.ClientModLoader_completeModLoading))
+                 {
+                     if (s != null)
+                     {
+                         reloadinstance.done().thenRunAsync(() ->
+                         {
+                             ConnectScreen.startConnecting(new TitleScreen(), this, new ServerAddress(s, i), (ServerData)null);
+                         }, this);
+                     }
+                     else if (this.shouldShowBanNotice())
+                     {
+                         this.setScreen(BanNoticeScreen.create((p_238185_) ->
+                         {
+                             if (p_238185_)
+                             {
+                                 Util.getPlatform().openUri("https://aka.ms/mcjavamoderation");
+                             }
+
+                             this.setScreen(new TitleScreen(true));
+                         }, this.multiplayerBan()));
+                     }
+                     else
+                     {
+                         this.setScreen(new TitleScreen(true));
+                     }
+                 }
+                 //
             });
         }, false));
-
-        if (s != null)
-        {
-            reloadinstance.done().thenRunAsync(() ->
-            {
-                ConnectScreen.startConnecting(new TitleScreen(), this, new ServerAddress(s, i), (ServerData)null);
-            }, this);
-        }
-        else if (this.shouldShowBanNotice())
-        {
-            this.setScreen(BanNoticeScreen.create((p_238185_) ->
-            {
-                if (p_238185_)
-                {
-                    Util.getPlatform().openUri("https://aka.ms/mcjavamoderation");
-                }
-
-                this.setScreen(new TitleScreen(true));
-            }, this.multiplayerBan()));
-        }
-        else
-        {
-            this.setScreen(new TitleScreen(true));
-        }
     }
 
     private static boolean countryEqualsISO3(Object p_210783_)
@@ -633,7 +854,7 @@
 
     private String createTitle()
     {
-        StringBuilder stringbuilder = new StringBuilder("Minecraft");
+        StringBuilder stringbuilder = new StringBuilder(minecriftVerString);
 
         if (checkModStatus().shouldReportAsModified())
         {
@@ -687,17 +908,14 @@
         return ModCheck.identify("vanilla", ClientBrandRetriever::getClientModName, "Client", Minecraft.class);
     }
 
-    private void rollbackResourcePacks(Throwable p_91240_)
-    {
-        if (this.resourcePackRepository.getSelectedIds().size() > 1)
-        {
-            this.clearResourcePacksOnError(p_91240_, (Component)null);
-        }
-        else
-        {
-            Util.throwAsRuntime(p_91240_);
+    private void rollbackResourcePacks(Throwable p_91240_) {
+        if (this.resourcePackRepository.getSelectedPacks().stream().anyMatch(e -> !e.isRequired())) { //Forge: This caused infinite loop if any resource packs are forced. Such as mod resources. So check if we can disable any.
+           this.clearResourcePacksOnError(p_91240_, (Component)null);
+        } else {
+           Util.throwAsRuntime(p_91240_);
         }
-    }
+
+     }
 
     public void clearResourcePacksOnError(Throwable pThrowable, @Nullable Component pErrorMessage)
     {
@@ -820,7 +1038,7 @@
             }, p_231389_);
         });
     }
-
+    
     private void onFullscreenError(int p_91114_, long p_91115_)
     {
         this.options.enableVsync().set(false);
@@ -884,17 +1102,43 @@
         if (pReport.getSaveFile() != null)
         {
             Bootstrap.realStdoutPrintln("#@!@# Game crashed! Crash report saved to: #@!@# " + pReport.getSaveFile());
-            System.exit(-1);
+            //Forge
+            if (Reflector.ServerLifecycleHooks_handleExit.exists())
+            {
+                Reflector.call(Reflector.ServerLifecycleHooks_handleExit, -1);
+            }
+            else
+            {
+                System.exit(-1);
+            }
+            //
         }
         else if (pReport.saveToFile(file2))
         {
             Bootstrap.realStdoutPrintln("#@!@# Game crashed! Crash report saved to: #@!@# " + file2.getAbsolutePath());
-            System.exit(-1);
+            //Forge
+            if (Reflector.ServerLifecycleHooks_handleExit.exists())
+            {
+                Reflector.call(Reflector.ServerLifecycleHooks_handleExit, -1);
+            }
+            else
+            {
+                System.exit(-1);
+            }
+            //
         }
         else
         {
             Bootstrap.realStdoutPrintln("#@?@# Game crashed! Crash report could not be saved. #@?@#");
-            System.exit(-2);
+
+            if (Reflector.ServerLifecycleHooks_handleExit.exists())
+            {
+                Reflector.call(Reflector.ServerLifecycleHooks_handleExit, -2);
+            }
+            else
+            {
+                System.exit(-2);
+            }
         }
     }
 
@@ -935,6 +1179,22 @@
 
                 this.setOverlay(new LoadingOverlay(this, this.resourceManager.createReload(Util.backgroundExecutor(), this, RESOURCE_RELOAD_INITIAL_TASK, list), (p_231394_) ->
                 {
+                	//Vivecraft
+                    if (this.menuWorldRenderer.isReady() && this.resourcePacksChanged)
+                    {
+                        try
+                        {
+                            this.menuWorldRenderer.destroy();
+                            this.menuWorldRenderer.prepare();
+                        }
+                        catch (Exception exception)
+                        {
+                            exception.printStackTrace();
+                        }
+                    }
+                    
+                    this.resourcePacksChanged = false;
+                    //
                     Util.ifElse(p_231394_, this::rollbackResourcePacks, () -> {
                         this.levelRenderer.allChanged();
                         this.reloadStateTracker.finishReload();
@@ -1058,10 +1318,12 @@
             LOGGER.error("setScreen called from non-game thread");
         }
 
-        if (this.screen != null)
-        {
-            this.screen.removed();
-        }
+        //Forge
+        //if (this.screen != null)
+        //{
+        //    this.screen.removed();
+        //}
+        //
 
         if (pGuiScreen == null && this.level == null)
         {
@@ -1079,6 +1341,29 @@
             }
         }
 
+        //Forge
+        Reflector.call(Reflector.ForgeHooksClient_clearGuiLayers, this);      
+        Screen old = this.screen;
+        if(pGuiScreen != null) {
+        	Object object = Reflector.newInstance(Reflector.ScreenOpenEvent_Constructor, old, pGuiScreen);
+        	if (object != null)
+        	{
+        		if (Reflector.postForgeBusEvent(object))
+        		{
+        			return;
+        		}
+
+        		pGuiScreen = (Screen)Reflector.call(object, Reflector.ScreenOpenEvent_getScreen);
+        	}
+        }     
+        if (old != null && pGuiScreen != old)
+        	old.removed();
+        //
+        
+		// VIVECRAFT
+		GuiHandler.onScreenChanged(this.screen, pGuiScreen, true);
+		// VIVECRAFT        
+        
         this.screen = pGuiScreen;
         BufferUploader.reset();
 
@@ -1141,6 +1426,14 @@
         {
             Util.timeSource = System::nanoTime;
 
+            try
+            {
+                this.vr.destroy();
+            }
+            catch (Exception exception)
+            {
+            }
+
             if (this.delayedCrash == null)
             {
                 System.exit(0);
@@ -1181,11 +1474,11 @@
             this.window.close();
         }
     }
-
+    
+    //Mojang why would you name it this. This is runGameLoop
     private void runTick(boolean pRenderLevel)
     {
         this.window.setErrorSection("Pre render");
-        long i = Util.getNanos();
 
         if (this.window.shouldClose())
         {
@@ -1211,105 +1504,258 @@
 
         if (pRenderLevel)
         {
-            int j = this.timer.advanceTime(Util.getMillis());
-            this.profiler.push("scheduledExecutables");
-            this.runAllTasks();
-            this.profiler.pop();
-            this.profiler.push("tick");
-
-            for (int k = 0; k < Math.min(10, j); ++k)
-            {
-                this.profiler.incrementCounter("clientTick");
-                this.tick();
-            }
+        	this.options.ofFastRender = false;
+        	++this.frameIndex;
+        	int j = this.timer.advanceTime(Util.getMillis());
+        	this.profiler.push("scheduledExecutables");
+        	this.runAllTasks();
+        	this.profiler.pop();
+
+        	try {
+        		this.vrRenderer.setupRenderConfiguration();
+        	}	
+        	catch (RenderConfigException renderconfigexception)	{
+        		this.screen = null;
+        		GlStateManager._viewport(0, 0, this.window.getScreenWidth(), this.window.getScreenHeight());
+
+        		if (this.overlay != null)
+        		{
+        			RenderSystem.clear(256, ON_OSX);
+        			Matrix4f matrix4f = Matrix4f.orthographic((float)(this.window.getScreenWidth() / this.window.getGuiScale()), (float)(this.window.getScreenHeight() / this.window.getGuiScale()), 1000.0F, 3000.0F);
+        			RenderSystem.setProjectionMatrix(matrix4f);
+        			PoseStack p = new PoseStack();
+        			p.translate(0, 0, -2000);
+        			this.overlay.render(p, 0, 0, 0.0F);
+        		}
+        		else
+        		{
+        			this.notifyMirror(LangHelper.get("vivecraft.messages.rendersetupfailed", renderconfigexception.error), true, 10000);
+        			this.drawNotifyMirror();
+
+        			if (this.frameIndex % 300L == 0L)
+        				System.out.println(renderconfigexception.title + " " + renderconfigexception.error);
+        			
+        			try
+        			{
+        				Thread.sleep(10L);
+        			}
+        			catch (InterruptedException e){}
+        		}
+
+        		this.window.updateDisplay();
+        		return;
+        	}
+        	catch (Exception exception2)
+        	{
+        		exception2.printStackTrace();
+        	}
+
+        	this.profiler.push("VR Poll/VSync");
+        	this.vr.poll(this.frameIndex);
+        	this.profiler.pop();
+        	this.vrPlayer.postPoll();
+        	this.profiler.push("tick");
+
+        	for (int k = 0; k < Math.min(10, j); ++k)
+        	{
+        		this.profiler.incrementCounter("clientTick");
+        		this.vrPlayer.preTick();
+        		this.tick();
+        		this.vrPlayer.postTick();
+        	}
 
-            this.profiler.pop();
+        	this.profiler.pop();
         }
 
+        this.options.ofFastRender = false;
+        this.profiler.push("setupRenderConfiguration");
         this.mouseHandler.turnPlayer();
         this.window.setErrorSection("Render");
         this.profiler.push("sound");
         this.soundManager.updateSource(this.gameRenderer.getMainCamera());
         this.profiler.pop();
-        this.profiler.push("render");
-        boolean flag1;
+        
+        try
+        {
+            this.checkGLError("pre render setup ");
+            this.vrRenderer.setupRenderConfiguration();
+            this.checkGLError("post render setup ");
+        }
+        catch (Exception exception1)
+        {
+            exception1.printStackTrace();
+        }
+
+        float f = this.pause ? this.pausePartialTick : this.timer.partialTick;
+        this.profiler.popPush("preRender");
+        this.vrPlayer.preRender(f);      
+        this.profiler.popPush("2D");
+        
+        //PoseStack posestack = RenderSystem.getModelViewStack();
+        //posestack.pushPose();
+        //RenderSystem.applyModelViewMatrix();
+        //RenderSystem.clear(16640, ON_OSX);
+        //this.mainRenderTarget.bindWrite(true);
+        FogRenderer.setupNoFog();
+        RenderSystem.enableTexture();
+        RenderSystem.enableCull();
+        this.profiler.push("Gui");
+        this.currentPass = RenderPass.GUI;
+        this.gameRenderer.getMainCamera().setup(this.level, this.getCameraEntity(), false, false, f);
 
-        if (!this.options.renderDebug && !this.metricsRecorder.isRecording())
+        if (!this.noRender)
         {
-            flag1 = false;
-            this.gpuUtilization = 0.0D;
+        	Reflector.call(Reflector.BasicEventHooks_onRenderTickStart, f);
         }
-        else
-        {
-            flag1 = this.currentFrameProfile == null || this.currentFrameProfile.isDone();
 
-            if (flag1)
-            {
-                TimerQuery.getInstance().ifPresent(TimerQuery::beginProfile);
-            }
+        GlStateManager._depthMask(true);
+        GlStateManager._colorMask(true, true, true, true);
+        this.mainRenderTarget = GuiHandler.guiFramebuffer;
+        this.mainRenderTarget.clear(Minecraft.ON_OSX);
+        this.mainRenderTarget.bindWrite(true);
+        
+        isGui = true;
+        this.gameRenderer.drawFramebufferNEW(f, pRenderLevel, new PoseStack());
+        isGui = false;
+        
+        if (org.vivecraft.gameplay.screenhandlers.KeyboardHandler.Showing && !this.vrSettings.physicalKeyboard)
+        {
+            this.mainRenderTarget = org.vivecraft.gameplay.screenhandlers.KeyboardHandler.Framebuffer;
+            this.mainRenderTarget.clear(Minecraft.ON_OSX);
+            this.mainRenderTarget.bindWrite(true);
+            this.gameRenderer.drawScreen(f, org.vivecraft.gameplay.screenhandlers.KeyboardHandler.UI, new PoseStack());
         }
 
-        PoseStack posestack = RenderSystem.getModelViewStack();
-        posestack.pushPose();
-        RenderSystem.applyModelViewMatrix();
-        RenderSystem.clear(16640, ON_OSX);
+        if (RadialHandler.isShowing())
+        {
+            this.mainRenderTarget = RadialHandler.Framebuffer;
+            this.mainRenderTarget.clear(Minecraft.ON_OSX);
         this.mainRenderTarget.bindWrite(true);
-        FogRenderer.setupNoFog();
-        this.profiler.push("display");
-        RenderSystem.enableTexture();
-        RenderSystem.enableCull();
+            this.gameRenderer.drawScreen(f, RadialHandler.UI, new PoseStack());
+        }
+
+        this.checkGLError("post 2d ");
         this.profiler.pop();
+        VRHotkeys.updateMovingThirdPersonCam();
+        this.profiler.popPush("sound");
+        this.currentPass = RenderPass.CENTER;
+        this.soundManager.updateSource(this.gameRenderer.getMainCamera());
+        this.profiler.pop();
+        int i1 = this.getFramerateLimit();
 
         if (!this.noRender)
         {
-            this.profiler.popPush("gameRenderer");
-            this.gameRenderer.render(this.pause ? this.pausePartialTick : this.timer.partialTick, i, pRenderLevel);
-            this.profiler.popPush("toasts");
-            this.toast.render(new PoseStack());
+            List<RenderPass> list = this.vrRenderer.getRenderPasses();
+
+            for (RenderPass renderpass : list)
+            {
+                this.currentPass = renderpass;
+
+                switch (renderpass)
+                {
+                    case LEFT:
+                    case RIGHT:
+                        this.mainRenderTarget = this.vrRenderer.framebufferVrRender;
+                        break;
+
+                    case CENTER:
+                        this.mainRenderTarget = this.vrRenderer.framebufferUndistorted;
+                        break;
+
+                    case THIRD:
+                        this.mainRenderTarget = this.vrRenderer.framebufferMR;
+                        break;
+
+                    case SCOPEL:
+                        this.mainRenderTarget = this.vrRenderer.telescopeFramebufferL;
+                        break;
+
+                    case SCOPER:
+                        this.mainRenderTarget = this.vrRenderer.telescopeFramebufferR;
+                        break;
+
+                    case CAMERA:
+                        this.mainRenderTarget = this.vrRenderer.cameraRenderFramebuffer;
+                }
+
+                this.profiler.push("Eye:" + this.currentPass.ordinal());
+                this.profiler.push("setup");
+                this.mainRenderTarget.bindWrite(true);
+                this.profiler.pop();
+                this.renderSingleView(renderpass.ordinal(), f, pRenderLevel);
             this.profiler.pop();
+
+                if (this.grabScreenShot)
+                {
+                    boolean flag;
+
+                    if (list.contains(RenderPass.CAMERA))
+                    {
+                        flag = renderpass == RenderPass.CAMERA;
+                    }
+                    else if (list.contains(RenderPass.CENTER))
+                    {
+                        flag = renderpass == RenderPass.CENTER;
+                    }
+                    else
+                    {
+                        flag = this.vrSettings.displayMirrorLeftEye ? renderpass == RenderPass.LEFT : renderpass == RenderPass.RIGHT;
         }
 
-        if (this.fpsPieResults != null)
+                    if (flag)
+                    {
+                        RenderTarget rendertarget = this.mainRenderTarget;
+
+                        if (renderpass == RenderPass.CAMERA)
         {
-            this.profiler.push("fpsPie");
-            this.renderFpsMeter(new PoseStack(), this.fpsPieResults);
-            this.profiler.pop();
+                            rendertarget = this.vrRenderer.cameraFramebuffer;
         }
 
-        this.profiler.push("blit");
         this.mainRenderTarget.unbindWrite();
-        posestack.popPose();
-        posestack.pushPose();
-        RenderSystem.applyModelViewMatrix();
-        this.mainRenderTarget.blitToScreen(this.window.getWidth(), this.window.getHeight());
+                        Utils.takeScreenshot(rendertarget);
+                        this.window.updateDisplay();
+                        this.grabScreenShot = false;
+                    }
+                }
+            }
 
-        if (flag1)
+            if (pRenderLevel)
+            {
+                this.vrPlayer.postRender(f);
+                this.profiler.push("Display/Reproject");
+
+                try
         {
-            TimerQuery.getInstance().ifPresent((p_231363_) ->
+                    this.vrRenderer.endFrame();
+                }
+                catch (Exception exception)
             {
-                this.currentFrameProfile = p_231363_.endProfile();
-            });
+                    LOGGER.error(exception.toString());
         }
 
-        posestack.popPose();
-        RenderSystem.applyModelViewMatrix();
-        this.profiler.popPush("updateDisplay");
-        this.window.updateDisplay();
-        int l = this.getFramerateLimit();
+                this.profiler.pop();
+                this.checkGLError("post submit ");
+            }
 
-        if (l < 260)
+            if (!this.noRender)
         {
-            RenderSystem.limitDisplayFPS(l);
+                Reflector.call(Reflector.BasicEventHooks_onRenderTickEnd, f);
         }
 
-        this.profiler.popPush("yield");
-        Thread.yield();
+            this.profiler.push("mirror");
+            this.mainRenderTarget.unbindWrite();
+            this.copyToMirror();
+            this.drawNotifyMirror();
+            this.checkGLError("post-mirror ");
         this.profiler.pop();
+        }
+
         this.window.setErrorSection("Post render");
+        this.window.updateDisplay();
         ++this.frames;
-        boolean flag = this.hasSingleplayerServer() && (this.screen != null && this.screen.isPauseScreen() || this.overlay != null && this.overlay.isPauseScreen()) && !this.singleplayerServer.isPublished();
+        boolean flag1 = this.hasSingleplayerServer() && (this.screen != null && this.screen.isPauseScreen() || this.overlay != null && this.overlay.isPauseScreen()) && !this.singleplayerServer.isPublished();
 
-        if (this.pause != flag)
+        if (this.pause != flag1)
         {
             if (this.pause)
             {
@@ -1320,26 +1766,14 @@
                 this.timer.partialTick = this.pausePartialTick;
             }
 
-            this.pause = flag;
-        }
-
-        long i1 = Util.getNanos();
-        long j1 = i1 - this.lastNanoTime;
-
-        if (flag1)
-        {
-            this.savedCpuDuration = j1;
+            this.pause = flag1;
         }
 
-        this.frameTimer.logFrameDuration(j1);
+        long k = Util.getNanos();
+        this.frameTimer.logFrameDuration(k - this.lastNanoTime);
         this.lastNanoTime = i1;
         this.profiler.push("fpsUpdate");
 
-        if (this.currentFrameProfile != null && this.currentFrameProfile.isDone())
-        {
-            this.gpuUtilization = (double)this.currentFrameProfile.get() * 100.0D / (double)this.savedCpuDuration;
-        }
-
         while (Util.getMillis() >= this.lastTime + 1000L)
         {
             String s;
@@ -1354,6 +1788,7 @@
             }
 
             fps = this.frames;
+            int l = this.getFramerateLimit();
             this.fpsString = String.format(Locale.ROOT, "%d fps T: %s%s%s%s B: %d%s", fps, l == 260 ? "inf" : l, this.options.enableVsync().get() ? " vsync" : "", this.options.graphicsMode().get(), this.options.cloudStatus().get() == CloudStatus.OFF ? "" : (this.options.cloudStatus().get() == CloudStatus.FAST ? " fast-clouds" : " fancy-clouds"), this.options.biomeBlendRadius().get(), s);
             this.lastTime += 1000L;
             this.frames = 0;
@@ -1429,14 +1864,19 @@
         int i = this.window.calculateScale(this.options.guiScale().get(), this.isEnforceUnicode());
         this.window.setGuiScale((double)i);
 
+        if (this.vrRenderer != null)
+        {
+            this.vrRenderer.reinitFrameBuffers("Main Window Changed");
+        }
+
         if (this.screen != null)
         {
             this.screen.resize(this, this.window.getGuiScaledWidth(), this.window.getGuiScaledHeight());
+            //FORGE
+            Reflector.call(Reflector.ForgeHooksClient_resizeGuiLayers, this, this.window.getGuiScaledWidth(), this.window.getGuiScaledHeight());
+            //
         }
 
-        RenderTarget rendertarget = this.getMainRenderTarget();
-        rendertarget.resize(this.window.getWidth(), this.window.getHeight(), ON_OSX);
-        this.gameRenderer.resize(this.window.getWidth(), this.window.getHeight());
         this.mouseHandler.setIgnoreFirstMove();
     }
 
@@ -1447,7 +1887,7 @@
 
     private int getFramerateLimit()
     {
-        return this.level != null || this.screen == null && this.overlay == null ? this.window.getFramerateLimit() : 60;
+        return this.level == null && (this.screen != null || this.overlay != null) ? 60 : this.window.getFramerateLimit();
     }
 
     public void emergencySave()
@@ -1678,6 +2118,17 @@
         }
     }
 
+//Vivecraft
+    public void drawProfiler()
+    {
+        if (this.fpsPieResults != null)
+        {
+            this.profiler.push("fpsPie");
+            this.renderFpsMeter(new PoseStack(), this.fpsPieResults);
+            this.profiler.pop();
+        }
+    }
+//
     private void renderFpsMeter(PoseStack pPoseStack, ProfileResults pProfilerResult)
     {
         List<ResultField> list = pProfilerResult.getTimes(this.debugPath);
@@ -1795,6 +2246,10 @@
 
     public void stop()
     {
+    	//Forge
+        if (this.isRunning()) 
+        	Reflector.postForgeBusEvent(Reflector.newInstance(Reflector.GameShuttingDownEvent_Constructor, null));
+        //
         this.running = false;
     }
 
@@ -1834,19 +2289,47 @@
             {
                 BlockHitResult blockhitresult = (BlockHitResult)this.hitResult;
                 BlockPos blockpos = blockhitresult.getBlockPos();
+                Object object = null;
 
-                if (!this.level.getBlockState(blockpos).isAir())
+                if (!this.level.isEmptyBlock(blockpos))
                 {
-                    Direction direction = blockhitresult.getDirection();
+                	//Forge
+                    object = Reflector.call(Reflector.ForgeHooksClient_OnClickInput, 0, this.options.keyAttack, InteractionHand.MAIN_HAND);
+
+                    if (object != null && Reflector.callBoolean(object, Reflector.Event_isCanceled))
+                    {
+                        if (Reflector.callBoolean(object, Reflector.ClickInputEvent_shouldSwingHand))
+                        {
+                            this.particleEngine.addBlockHitEffects(blockpos, blockhitresult);
+                            this.player.swingArm(InteractionHand.MAIN_HAND, VRFirstPersonArmSwing.Attack);
+                        }
 
+                        return;
+                    }
+                    //
+                    
+                    Direction direction = blockhitresult.getDirection();
+                    //Forge
                     if (this.gameMode.continueDestroyBlock(blockpos, direction))
                     {
-                        this.particleEngine.crack(blockpos, direction);
-                        this.player.swing(InteractionHand.MAIN_HAND);
+                        if (object != null)
+                        {
+                            if (Reflector.callBoolean(object, Reflector.ClickInputEvent_shouldSwingHand))
+                            {
+                                this.particleEngine.addBlockHitEffects(blockpos, blockhitresult);
+                                this.player.swingArm(InteractionHand.MAIN_HAND, VRFirstPersonArmSwing.Attack);
+                            }
+                        }
+                        else
+                        {
+                            this.particleEngine.crack(blockpos, direction);
+                            this.player.swingArm(InteractionHand.MAIN_HAND, VRFirstPersonArmSwing.Attack);
+                        }
                     }
+                    //
                 }
             }
-            else
+            else if (this.vrSettings.seated)
             {
                 this.gameMode.stopDestroyBlock();
             }
@@ -1855,87 +2338,131 @@
 
     private boolean startAttack()
     {
-        if (this.missTime > 0)
-        {
-            return false;
-        }
-        else if (this.hitResult == null)
-        {
-            LOGGER.error("Null returned as 'hitResult', this shouldn't happen!");
+    	if (this.missTime > 0)
+    	{
+    		return false;
+    	}
+    	else if (this.hitResult == null)
+    	{
+    		LOGGER.error("Null returned as 'hitResult', this shouldn't happen!");
+
+    		if (this.gameMode.hasMissTime())
+    		{
+    			this.missTime = 10;
+    		}
+
+    		return false;
+    	}
+    	else if (this.player.isHandsBusy())
+    	{
+    		return false;
+    	}
+    	else
+    	{
+    		boolean flag = false;
+    		//Forge
+    		Object object = Reflector.call(Reflector.ForgeHooksClient_OnClickInput, 0, this.options.keyAttack, InteractionHand.MAIN_HAND);
+    		if (object==null || !Reflector.callBoolean(object, Reflector.Event_isCanceled)) {
+    		//      			
+    			//Forge
+    			HitResult.Type hitType = this.hitResult.getType();
+    			if (Reflector.IForgePlayer_canHit.exists())
+    			{
+    				if(this.hitResult instanceof EntityHitResult entityHit) { // Forge: Perform attack range checks here, instead of in GameRenderer#pick, so extended-reach interactions work.
+    					if(!Reflector.callBoolean(this.player, Reflector.IForgePlayer_canHit, entityHit.getEntity(), 0))
+    						hitType = HitResult.Type.MISS;
+    				}
+    			}  			
+    			switch (hitType)
+    			//
+    			{
+    			case ENTITY:
+    				this.gameMode.attack(this.player, ((EntityHitResult)this.hitResult).getEntity());
+    				break;
+
+    			case BLOCK:
+    				BlockHitResult blockhitresult = (BlockHitResult)this.hitResult;
+    				BlockPos blockpos = blockhitresult.getBlockPos();
+
+    				if (!this.level.getBlockState(blockpos).isAir())
+    				{
+    					this.gameMode.startDestroyBlock(blockpos, blockhitresult.getDirection());
+
+    					if (this.level.getBlockState(blockpos).isAir())
+    					{
+    						flag = true;
+    					}
+
+    					break;
+    				}
+
+    			case MISS:
+    				if (this.gameMode.hasMissTime())
+    				{
+    					this.missTime = 10;
+    				}
+
+    				this.player.resetAttackStrengthTicker();
+    				Reflector.call(Reflector.ForgeHooks_onEmptyLeftClick, this.player);
+    			}
+    		}
+    		if (object == null || Reflector.callBoolean(object, Reflector.ClickInputEvent_shouldSwingHand))
+    		{
+    			this.player.swing(InteractionHand.MAIN_HAND);
+    		}
+    		return flag;
+    	}
+    }
+
+    public void startUseItem()
+    {
+        if (!this.gameMode.isDestroying() || !this.vrSettings.seated)
+        {
+            if(vrSettings.rightclickDelay == VRSettings.RightClickDelay.VANILLA)
+            	this.rightClickDelay = 4;
+            else if(vrSettings.rightclickDelay == VRSettings.RightClickDelay.SLOW)
+            	this.rightClickDelay = 6;
+            else if(vrSettings.rightclickDelay == VRSettings.RightClickDelay.SLOWER)
+            	this.rightClickDelay = 8;
+            else if(vrSettings.rightclickDelay == VRSettings.RightClickDelay.SLOWEST)
+            	this.rightClickDelay = 10;         
+            
 
-            if (this.gameMode.hasMissTime())
+            if (!this.player.isHandsBusy())
             {
-                this.missTime = 10;
-            }
-
-            return false;
-        }
-        else if (this.player.isHandsBusy())
-        {
-            return false;
-        }
-        else
-        {
-            boolean flag = false;
-
-            switch (this.hitResult.getType())
-            {
-                case ENTITY:
-                    this.gameMode.attack(this.player, ((EntityHitResult)this.hitResult).getEntity());
-                    break;
-
-                case BLOCK:
-                    BlockHitResult blockhitresult = (BlockHitResult)this.hitResult;
-                    BlockPos blockpos = blockhitresult.getBlockPos();
-
-                    if (!this.level.getBlockState(blockpos).isAir())
-                    {
-                        this.gameMode.startDestroyBlock(blockpos, blockhitresult.getDirection());
-
-                        if (this.level.getBlockState(blockpos).isAir())
-                        {
-                            flag = true;
-                        }
-
-                        break;
-                    }
-
-                case MISS:
-                    if (this.gameMode.hasMissTime())
-                    {
-                        this.missTime = 10;
-                    }
-
-                    this.player.resetAttackStrengthTicker();
-            }
-
-            this.player.swing(InteractionHand.MAIN_HAND);
-            return flag;
-        }
-    }
-
-    private void startUseItem()
-    {
-        if (!this.gameMode.isDestroying())
-        {
-            this.rightClickDelay = 4;
-
-            if (!this.player.isHandsBusy())
-            {
-                if (this.hitResult == null)
-                {
-                    LOGGER.warn("Null returned as 'hitResult', this shouldn't happen!");
-                }
+                if (this.hitResult == null)
+                {
+                    LOGGER.warn("Null returned as 'hitResult', this shouldn't happen!");
+                }
 
                 for (InteractionHand interactionhand : InteractionHand.values())
                 {
+                	
+                	//Forge
+                	net.minecraftforge.client.event.InputEvent.InteractionKeyMappingTriggered object = (InteractionKeyMappingTriggered) Reflector.call(Reflector.ForgeHooksClient_OnClickInput, 1, this.options.keyUse, interactionhand);
+                	if (object != null && Reflector.callBoolean(object, Reflector.Event_isCanceled))
+                	{
+                		if (Reflector.callBoolean(object, Reflector.ClickInputEvent_shouldSwingHand))
+                		{
+                			this.player.swing(interactionhand);
+                		}
+
+                		return;
+                	}
+                	//
+                	
                     ItemStack itemstack = this.player.getItemInHand(interactionhand);
 
+                    if (vrSettings.seated || !TelescopeTracker.isTelescope(itemstack))
+                    {
+                        NetworkHelper.sendActiveHand((byte)interactionhand.ordinal());
+
                     if (this.hitResult != null)
                     {
                         switch (this.hitResult.getType())
                         {
                             case ENTITY:
+                                    //this.physicalGuiManager.preClickAction();
                                 EntityHitResult entityhitresult = (EntityHitResult)this.hitResult;
                                 Entity entity = entityhitresult.getEntity();
 
@@ -1953,9 +2480,9 @@
 
                                 if (interactionresult.consumesAction())
                                 {
-                                    if (interactionresult.shouldSwing())
+                                        if (interactionresult.shouldSwing() && (object == null || Reflector.callBoolean(object, Reflector.ClickInputEvent_shouldSwingHand)))
                                     {
-                                        this.player.swing(interactionhand);
+                                            this.player.swingArm(interactionhand, VRFirstPersonArmSwing.Use);
                                     }
 
                                     return;
@@ -1966,13 +2493,16 @@
                             case BLOCK:
                                 BlockHitResult blockhitresult = (BlockHitResult)this.hitResult;
                                 int i = itemstack.getCount();
-                                InteractionResult interactionresult1 = this.gameMode.useItemOn(this.player, interactionhand, blockhitresult);
+                                    InteractionResult interactionresult1 = this.gameMode.useItemOn(this.player, interactionhand, blockhitresult);
 
                                 if (interactionresult1.consumesAction())
                                 {
                                     if (interactionresult1.shouldSwing())
                                     {
-                                        this.player.swing(interactionhand);
+                                            if (object == null || Reflector.callBoolean(object, Reflector.ClickInputEvent_shouldSwingHand))
+                                            {
+                                                this.player.swingArm(interactionhand, VRFirstPersonArmSwing.Use);
+                                            }
 
                                         if (!itemstack.isEmpty() && (itemstack.getCount() != i || this.gameMode.hasInfiniteItems()))
                                         {
@@ -1990,15 +2520,22 @@
                         }
                     }
 
+                        //this.physicalGuiManager.preClickAction();
+
+                        if (itemstack.isEmpty() && (this.hitResult == null || this.hitResult.getType() == HitResult.Type.MISS))
+                        {
+                            Reflector.call(Reflector.ForgeHooks_onEmptyClick, this.player, interactionhand);
+                        }
+
                     if (!itemstack.isEmpty())
                     {
-                        InteractionResult interactionresult2 = this.gameMode.useItem(this.player, interactionhand);
+                            InteractionResult interactionresult2 = this.gameMode.useItem(this.player, interactionhand);
 
                         if (interactionresult2.consumesAction())
                         {
                             if (interactionresult2.shouldSwing())
                             {
-                                this.player.swing(interactionhand);
+                                    this.player.swingArm(interactionhand, VRFirstPersonArmSwing.Use);
                             }
 
                             this.gameRenderer.itemInHandRenderer.itemUsed(interactionhand);
@@ -2009,6 +2546,7 @@
             }
         }
     }
+    }
 
     public MusicManager getMusicManager()
     {
@@ -2017,11 +2555,17 @@
 
     public void tick()
     {
-        if (this.rightClickDelay > 0)
+    	++this.tickCounter;
+
+    	if (this.rightClickDelay > 0)
         {
             --this.rightClickDelay;
         }
-
+    	
+    	//Forge
+    	Reflector.call(Reflector.BasicEventHooks_onPreClientTick);
+    	//
+    	
         this.profiler.push("gui");
         this.chatListener.tick();
         this.gui.tick(this.pause);
@@ -2036,11 +2580,7 @@
         }
 
         this.profiler.popPush("textures");
-
-        if (this.level != null)
-        {
-            this.textureManager.tick();
-        }
+        this.textureManager.tick();
 
         if (this.screen == null && this.player != null)
         {
@@ -2086,6 +2626,10 @@
             this.gui.clearCache();
         }
 
+        this.profiler.popPush("vrProcessInputs");
+        this.vr.processInputs();
+        this.vr.processBindings();
+
         if (this.overlay == null && (this.screen == null || this.screen.passEvents))
         {
             this.profiler.popPush("Keybindings");
@@ -2097,8 +2641,30 @@
             }
         }
 
+        this.profiler.popPush("vrInputActionsTick");
+
+        for (VRInputAction vrinputaction : this.vr.getInputActions())
+        {
+            vrinputaction.tick();
+        }
+
+        if (this.vrSettings.displayMirrorMode == VRSettings.MirrorMode.MIXED_REALITY || this.vrSettings.displayMirrorMode == VRSettings.MirrorMode.THIRD_PERSON)
+        {
+            VRHotkeys.handleMRKeys();
+        }
+
         if (this.level != null)
         {
+            if (this.player != null)
+            {
+                this.vrPlayer.updateFreeMove();
+
+                if (this.vrPlayer.teleportWarningTimer >= 0 && --this.vrPlayer.teleportWarningTimer == 0)
+                {
+                    this.gui.getChat().addMessage(Component.translatable("vivecraft.messages.noserverplugin"));
+                }
+            }
+
             this.profiler.popPush("gameRenderer");
 
             if (!this.pause)
@@ -2130,6 +2696,13 @@
             this.gameRenderer.shutdownEffect();
         }
 
+        if (this.menuWorldRenderer != null)
+        {
+            this.menuWorldRenderer.tick();
+        }
+        
+        PlayerModelController.getInstance().tick();
+
         if (!this.pause)
         {
             this.musicManager.tick();
@@ -2201,24 +2774,23 @@
         this.profiler.popPush("keyboard");
         this.keyboardHandler.tick();
         this.profiler.pop();
+        //Forge
+        Reflector.call(Reflector.BasicEventHooks_onPostClientTick);
+        //
     }
 
-    private boolean isMultiplayerServer()
+    public boolean isMultiplayerServer()
     {
         return !this.isLocalServer || this.singleplayerServer != null && this.singleplayerServer.isPublished();
     }
 
     private void handleKeybinds()
     {
-        for (; this.options.keyTogglePerspective.consumeClick(); this.levelRenderer.needsUpdate())
+        while (this.options.keyTogglePerspective.consumeClick())
         {
-            CameraType cameratype = this.options.getCameraType();
-            this.options.setCameraType(this.options.getCameraType().cycle());
-
-            if (cameratype.isFirstPerson() != this.options.getCameraType().isFirstPerson())
-            {
-                this.gameRenderer.checkEntityPostEffect(this.options.getCameraType().isFirstPerson() ? this.getCameraEntity() : null);
-            }
+            this.vrSettings.setOptionValue(VRSettings.VrOptions.MIRROR_DISPLAY);
+            this.notifyMirror(this.vrSettings.getButtonDisplayString(VRSettings.VrOptions.MIRROR_DISPLAY), false, 3000);
+            this.levelRenderer.needsUpdate();
         }
 
         while (this.options.keySmoothCamera.consumeClick())
@@ -2297,7 +2869,7 @@
         {
             if (!this.player.isSpectator() && this.player.drop(Screen.hasControlDown()))
             {
-                this.player.swing(InteractionHand.MAIN_HAND);
+                this.player.swingArm(InteractionHand.MAIN_HAND, VRFirstPersonArmSwing.Attack);
             }
         }
 
@@ -2315,8 +2887,9 @@
 
         if (this.player.isUsingItem())
         {
-            if (!this.options.keyUse.isDown())
+            if (!this.options.keyUse.isDown() && (!this.bowTracker.isActive(this.player) || this.vrSettings.seated) && !this.autoFood.isEating())
             {
+                NetworkHelper.sendActiveHand((byte)this.player.getUsedItemHand().ordinal());
                 this.gameMode.releaseUsingItem(this.player);
             }
 
@@ -2456,6 +3029,15 @@
 
     public void setLevel(ClientLevel pLevelClient)
     {
+        this.vrPlayer.setRoomOrigin(0.0D, 0.0D, 0.0D, true);
+
+        //Forge
+        if (this.level != null)
+        {
+            Reflector.postForgeBusEvent(Reflector.newInstance(Reflector.WorldEvent_Unload_Constructor, this.level));
+        }
+        //
+
         ProgressScreen progressscreen = new ProgressScreen(true);
         progressscreen.progressStartNoAbort(Component.translatable("connect.joining"));
         this.updateScreenAndTick(progressscreen);
@@ -2496,29 +3078,38 @@
         IntegratedServer integratedserver = this.singleplayerServer;
         this.singleplayerServer = null;
         this.gameRenderer.resetData();
+        //Forge
+        Reflector.call(Reflector.ClientHooks_firePlayerLogout, this.gameMode, this.player);
+        //
         this.gameMode = null;
         this.narrator.clear();
         this.updateScreenAndTick(pScreen);
 
         if (this.level != null)
         {
-            if (integratedserver != null)
-            {
-                this.profiler.push("waitForServer");
-
-                while (!integratedserver.isShutdown())
-                {
-                    this.runTick(false);
-                }
-
-                this.profiler.pop();
-            }
-
-            this.clientPackSource.clearServerPack();
-            this.gui.onDisconnected();
-            this.currentServer = null;
-            this.isLocalServer = false;
-            this.game.onLeaveGameSession();
+        	//Forge
+        	Reflector.postForgeBusEvent(Reflector.newInstance(Reflector.WorldEvent_Unload_Constructor, this.level));
+        	//
+        	if (integratedserver != null)
+        	{
+        		this.profiler.push("waitForServer");
+
+        		while (!integratedserver.isShutdown())
+        		{
+        			this.runTick(false);
+        		}
+
+        		this.profiler.pop();
+        	}
+
+        	this.clientPackSource.clearServerPack();
+        	this.gui.onDisconnected();
+        	this.currentServer = null;
+        	this.isLocalServer = false;
+        	//Forge
+        	Reflector.call(Reflector.ClientHooks_handleClientWorldClosing, this.level);
+        	//
+        	this.game.onLeaveGameSession();
         }
 
         this.level = null;
@@ -2619,9 +3210,11 @@
         return !instance.options.hideGui;
     }
 
+    //Silly forge workaround for now
+    public static boolean isGui = false;
     public static boolean useFancyGraphics()
     {
-        return instance.options.graphicsMode().get().getId() >= GraphicsStatus.FANCY.getId();
+  	        return isGui ? false : instance.options.graphicsMode().get().getId() >= GraphicsStatus.FANCY.getId();
     }
 
     public static boolean useShaderTransparency()
@@ -2638,6 +3231,19 @@
     {
         if (this.hitResult != null && this.hitResult.getType() != HitResult.Type.MISS)
         {
+        	//Forge
+            Object object = Reflector.call(Reflector.ForgeHooksClient_OnClickInput, 2, this.options.keyPickItem, InteractionHand.MAIN_HAND);
+
+            if (object != null && !Reflector.callBoolean(object, Reflector.Event_isCanceled))
+            {
+                Reflector.call(Reflector.ForgeHooks_onPickBlock, this.hitResult, this.player, this.level);
+            }
+
+            if (object != null)
+            {
+                return;
+            }
+            //
             boolean flag = this.player.getAbilities().instabuild;
             BlockEntity blockentity = null;
             HitResult.Type hitresult$type = this.hitResult.getType();
@@ -3359,23 +3965,37 @@
         return this.renderBuffers;
     }
 
-    private static Pack createClientPackAdapter(String p_167934_, Component p_167935_, boolean p_167936_, Supplier<PackResources> p_167937_, PackMetadataSection p_167938_, Pack.Position p_167939_, PackSource p_167940_)
-    {
+    private static Pack createClientPackAdapter(String p_167934_, Component p_167935_, boolean p_167936_, Supplier<PackResources> p_167937_, PackMetadataSection p_167938_, Pack.Position p_167939_, PackSource p_167940_, boolean hidden) {
         int i = p_167938_.getPackFormat();
         Supplier<PackResources> supplier = p_167937_;
-
-        if (i <= 3)
-        {
+        if (i <= 3) {
             supplier = adaptV3(p_167937_);
         }
 
-        if (i <= 4)
-        {
+        if (i <= 4) {
             supplier = adaptV4(supplier);
         }
 
-        return new Pack(p_167934_, p_167935_, p_167936_, supplier, p_167938_, PackType.CLIENT_RESOURCES, p_167939_, p_167940_);
-    }
+        return new Pack(p_167934_, p_167935_, p_167936_, supplier, p_167938_, PackType.CLIENT_RESOURCES, p_167939_, p_167940_, hidden);
+     }
+    
+//    private static Pack createClientPackAdapter(String p_167934_, Component p_167935_, boolean p_167936_, Supplier<PackResources> p_167937_, PackMetadataSection p_167938_, Pack.Position p_167939_, PackSource p_167940_)
+//    {
+//        int i = p_167938_.getPackFormat();
+//        Supplier<PackResources> supplier = p_167937_;
+//
+//        if (i <= 3)
+//        {
+//            supplier = adaptV3(p_167937_);
+//        }
+//
+//        if (i <= 4)
+//        {
+//            supplier = adaptV4(supplier);
+//        }
+        //
+//        return new Pack(p_167934_, p_167935_, p_167936_, supplier, p_167938_, PackType.CLIENT_RESOURCES, p_167939_, p_167940_);
+//}
 
     private static Supplier<PackResources> adaptV3(Supplier<PackResources> pResourcePackSupplier)
     {
@@ -3490,4 +4110,581 @@
 
         public abstract boolean isChatAllowed(boolean p_168035_);
     }
+
+    public void printChatMessage(String msg)
+    {
+        if (this.level != null)
+        {
+            Component component = Component.literal(msg);
+            this.gui.getChat().addMessage(component);
+        }
+    }
+
+    private void copyToMirror()
+    {
+        // TODO: fix mixed reality... again
+        if (this.vrSettings.displayMirrorMode == VRSettings.MirrorMode.MIXED_REALITY)
+            this.vrSettings.displayMirrorMode = VRSettings.MirrorMode.CROPPED;
+
+        if (this.vrSettings.displayMirrorMode == VRSettings.MirrorMode.OFF && this.vr.isHMDTracking())
+        {
+            this.notifyMirror("Mirror is OFF", true, 1000);
+        }
+        else if (this.vrSettings.displayMirrorMode == VRSettings.MirrorMode.MIXED_REALITY)
+        {
+            if (VRShaders._DepthMask_shaderProgramId != 0)
+            {
+                this.doMixedRealityMirror();
+            }
+            else
+            {
+                this.notifyMirror("Shader compile failed, see log", true, 10000);
+            }
+        }
+        else if (this.vrSettings.displayMirrorMode == VRSettings.MirrorMode.DUAL)
+        {
+            RenderTarget rendertarget = this.vrRenderer.framebufferEye0;
+            RenderTarget rendertarget1 = this.vrRenderer.framebufferEye1;
+            
+            if (rendertarget != null)
+            {
+                rendertarget.blitToScreen(0, this.window.getScreenWidth() / 2, this.window.getScreenHeight(), 0, true, 0.0F, 0.0F, false);
+            }
+
+            if (rendertarget1 != null)
+            {
+                rendertarget1.blitToScreen(this.window.getScreenWidth() / 2, this.window.getScreenWidth() / 2, this.window.getScreenHeight(), 0, true, 0.0F, 0.0F, false);
+            }
+        }
+        else
+        {
+            float xcrop = 0.0F;
+            float ycrop = 0.0F;
+            boolean ar = false;
+            RenderTarget source = this.vrRenderer.framebufferEye0;
+
+            if (this.vrSettings.displayMirrorMode == VRSettings.MirrorMode.FIRST_PERSON)
+            {
+                source = this.vrRenderer.framebufferUndistorted;
+            }
+            else if (this.vrSettings.displayMirrorMode == VRSettings.MirrorMode.THIRD_PERSON)
+            {
+                source = this.vrRenderer.framebufferMR;
+            }
+            else if (this.vrSettings.displayMirrorMode == VRSettings.MirrorMode.GUI)
+            {
+            	source = GuiHandler.guiFramebuffer;
+            }
+            else if (this.vrSettings.displayMirrorMode == VRSettings.MirrorMode.SINGLE || this.vrSettings.displayMirrorMode == VRSettings.MirrorMode.OFF)
+            {
+                if (!this.vrSettings.displayMirrorLeftEye)
+                    source = this.vrRenderer.framebufferEye1;
+            }
+            else if (this.vrSettings.displayMirrorMode == VRSettings.MirrorMode.CROPPED)
+            {
+                if (!this.vrSettings.displayMirrorLeftEye)
+                    source = this.vrRenderer.framebufferEye1;
+
+                xcrop = 0.15F;
+                ycrop = 0.15F;
+                ar = true;
+            }
+            //Debug
+            //source = GuiHandler.guiFramebuffer;
+            //source = vrRenderer.telescopeFramebufferR;
+            //
+            if (source != null)
+            {
+                source.blitToScreen(0, this.window.getScreenWidth(), this.window.getScreenHeight(), 0, true, xcrop, ycrop, ar);
+            }
+        }
+    }
+
+    private void doMixedRealityMirror()
+    {
+        boolean flag = Config.isShaders();
+        boolean flag1 = this.vrSettings.mixedRealityUnityLike && this.vrSettings.mixedRealityAlphaMask;
+
+        if (!flag1)
+        {
+            GlStateManager._clearColor((float)this.vrSettings.mixedRealityKeyColor.getRed() / 255.0F, (float)this.vrSettings.mixedRealityKeyColor.getGreen() / 255.0F, (float)this.vrSettings.mixedRealityKeyColor.getBlue() / 255.0F, 1.0F);
+        }
+        else
+        {
+            GlStateManager._clearColor(0.0F, 0.0F, 0.0F, 1.0F);
+        }
+
+        GlStateManager.clear(16640);
+        Vec3 vec3 = this.vrPlayer.vrdata_room_pre.getHeadPivot().subtract(this.vrPlayer.vrdata_room_pre.getEye(RenderPass.THIRD).getPosition());
+        com.mojang.math.Matrix4f matrix4f = this.vrPlayer.vrdata_room_pre.getEye(RenderPass.THIRD).getMatrix().transposed().toMCMatrix();
+        Vector3 vector3 = this.vrPlayer.vrdata_room_pre.getEye(RenderPass.THIRD).getMatrix().transform(Vector3.forward());
+        GlStateManager._glUseProgram(VRShaders._DepthMask_shaderProgramId);
+        this.gameRenderer.thirdPassProjectionMatrix.store(this.matrixBuffer);
+        ((Buffer)this.matrixBuffer).rewind();
+        ARBShaderObjects.glUniformMatrix4fvARB(VRShaders._DepthMask_projectionMatrix, false, this.matrixBuffer);
+        matrix4f.store(this.matrixBuffer);
+        ((Buffer)this.matrixBuffer).rewind();
+        ARBShaderObjects.glUniformMatrix4fvARB(VRShaders._DepthMask_viewMatrix, false, this.matrixBuffer);
+        ARBShaderObjects.glUniform1iARB(VRShaders._DepthMask_colorTexUniform, 1);
+        ARBShaderObjects.glUniform1iARB(VRShaders._DepthMask_depthTexUniform, 2);
+        ARBShaderObjects.glUniform3fARB(VRShaders._DepthMask_hmdViewPosition, (float)vec3.x, (float)vec3.y, (float)vec3.z);
+        ARBShaderObjects.glUniform3fARB(VRShaders._DepthMask_hmdPlaneNormal, -vector3.getX(), 0.0F, -vector3.getZ());
+        ARBShaderObjects.glUniform3fARB(VRShaders._DepthMask_keyColorUniform, (float)this.vrSettings.mixedRealityKeyColor.getRed() / 255.0F, (float)this.vrSettings.mixedRealityKeyColor.getGreen() / 255.0F, (float)this.vrSettings.mixedRealityKeyColor.getBlue() / 255.0F);
+        ARBShaderObjects.glUniform1iARB(VRShaders._DepthMask_alphaModeUniform, flag1 ? 1 : 0);
+        GlStateManager._activeTexture(33985);
+        this.vrRenderer.framebufferMR.bindRead();
+        GlStateManager._activeTexture(33986);
+
+        if (flag && Shaders.dfb != null)
+        {
+            GlStateManager._bindTexture(Shaders.dfb.depthTextures.get(0));
+        }
+        else
+        {
+            GlStateManager._bindTexture(this.vrRenderer.framebufferMR.getDepthBufferId());
+        }
+
+        GlStateManager._activeTexture(33984);
+
+        for (int i = 0; i < (flag1 ? 3 : 2); ++i)
+        {
+            int j = this.window.getScreenWidth() / 2;
+            int k = this.window.getScreenHeight();
+            int l = this.window.getScreenWidth() / 2 * i;
+            int i1 = 0;
+
+            if (this.vrSettings.mixedRealityUnityLike)
+            {
+                j = this.window.getScreenWidth() / 2;
+                k = this.window.getScreenHeight() / 2;
+
+                if (this.vrSettings.mixedRealityAlphaMask && i == 2)
+                {
+                    l = this.window.getScreenWidth() / 2;
+                    i1 = this.window.getScreenHeight() / 2;
+                }
+                else
+                {
+                    l = 0;
+                    i1 = this.window.getScreenHeight() / 2 * (1 - i);
+                }
+            }
+
+            ARBShaderObjects.glUniform2fARB(VRShaders._DepthMask_resolutionUniform, (float)j, (float)k);
+            ARBShaderObjects.glUniform2fARB(VRShaders._DepthMask_positionUniform, (float)l, (float)i1);
+            ARBShaderObjects.glUniform1iARB(VRShaders._DepthMask_passUniform, i);
+            this.vrRenderer.framebufferMR.blitToScreen(l, j, k, i1, true, 0.0F, 0.0F, false);
+        }
+
+        GlStateManager._glUseProgram(0);
+
+        if (this.vrSettings.mixedRealityUnityLike)
+        {
+            if (this.vrSettings.mixedRealityUndistorted)
+            {
+                this.vrRenderer.framebufferUndistorted.blitToScreen(this.window.getScreenWidth() / 2, this.window.getScreenWidth() / 2, this.window.getScreenHeight() / 2, 0, true, 0.0F, 0.0F, false);
+            }
+            else
+            {
+                this.vrRenderer.framebufferEye0.blitToScreen(this.window.getScreenWidth() / 2, this.window.getScreenWidth() / 2, this.window.getScreenHeight() / 2, 0, true, 0.0F, 0.0F, false);
+            }
+        }
+    }
+
+    private void checkGLError(String message)
+    {
+        Config.checkGlError(message);
+    }
+
+    public void initMinecrift() throws Exception
+    {
+        this.vr.init();
+
+        if (!Main.oculus)
+        {
+            this.vrRenderer = new OpenVRStereoRenderer(this.vr);
+        }
+        else
+        {
+            this.vrRenderer = new OVR_StereoRenderer(this.vr);
+        }
+
+        this.vrPlayer = new VRPlayer();
+        this.vrRenderer.lastGuiScale = this.options.guiScale().get();
+        this.vrPlayer.registerTracker(this.backpackTracker);
+        this.vrPlayer.registerTracker(this.bowTracker);
+        this.vrPlayer.registerTracker(this.climbTracker);
+        this.vrPlayer.registerTracker(this.autoFood);
+        this.vrPlayer.registerTracker(this.jumpTracker);
+        this.vrPlayer.registerTracker(this.rowTracker);
+        this.vrPlayer.registerTracker(this.runTracker);
+        this.vrPlayer.registerTracker(this.sneakTracker);
+        this.vrPlayer.registerTracker(this.swimTracker);
+        this.vrPlayer.registerTracker(this.swingTracker);
+        this.vrPlayer.registerTracker(this.interactTracker);
+        this.vrPlayer.registerTracker(this.teleportTracker);
+        this.vrPlayer.registerTracker(this.horseTracker);
+        this.vrPlayer.registerTracker(this.vehicleTracker);
+        //this.vrPlayer.registerTracker(this.physicalGuiManager);
+        this.vrPlayer.registerTracker(this.crawlTracker);
+        this.vrPlayer.registerTracker(this.cameraTracker);
+    }
+
+    private static void sleepNanos(long nanoDelay)
+    {
+        long i = System.nanoTime() + nanoDelay;
+
+        do
+        {
+            Thread.yield();
+        }
+        while (System.nanoTime() < i);
+    }
+
+    private void addRunTickTimeNanos(long runTickTime)
+    {
+        int i = 0;
+        this.medianRunTickTimeNanos = runTickTime;
+
+        if (this.vrSettings.smoothRunTickCount < 1)
+        {
+            this.vrSettings.smoothRunTickCount = 1;
+        }
+
+        if (this.vrSettings.smoothRunTickCount % 2 == 0)
+        {
+            ++this.vrSettings.smoothRunTickCount;
+        }
+
+        this.runTickTimeNanos.addFirst(runTickTime);
+
+        while (this.runTickTimeNanos.size() > this.vrSettings.smoothRunTickCount)
+        {
+            this.runTickTimeNanos.removeLast();
+        }
+
+        if (this.runTickTimeNanos.size() == this.vrSettings.smoothRunTickCount)
+        {
+            Long[] along = new Long[this.runTickTimeNanos.size()];
+
+            for (Iterator iterator = this.runTickTimeNanos.iterator(); iterator.hasNext(); ++i)
+            {
+                along[i] = (Long)iterator.next();
+            }
+
+            Arrays.sort((Object[])along);
+            this.medianRunTickTimeNanos = along[along.length / 2];
+        }
+    }
+
+    private long getMedianRunTickTimeNanos()
+    {
+        return this.medianRunTickTimeNanos;
+    }
+
+    public void triggerYawTransition(boolean isPositive)
+    {
+    }
+
+    public void print(String s)
+    {
+        s = s.replace("\n", "\n[Minecrift] ");
+        System.out.println("[Minecrift] " + s);
+    }
+
+    private void renderSingleView(int eye, float nano, boolean renderworld)
+    {
+        GlStateManager._clearColor(0.0F, 0.0F, 0.0F, 1.0F);
+        GlStateManager.clear(16640);
+        GlStateManager._enableTexture();
+        GlStateManager._enableDepthTest();
+        this.profiler.push("updateCameraAndRender");
+        this.gameRenderer.render(nano, System.nanoTime(), renderworld);
+        this.profiler.pop();
+        this.checkGLError("post game render " + eye);
+
+        if (this.currentPass == RenderPass.LEFT || this.currentPass == RenderPass.RIGHT)
+        {
+            this.profiler.push("postprocesseye");
+            RenderTarget rendertarget = this.mainRenderTarget;
+
+            if (this.vrSettings.useFsaa)
+            {
+                this.profiler.push("fsaa");
+                this.vrRenderer.doFSAA(Config.isShaders());
+                rendertarget = this.vrRenderer.fsaaLastPassResultFBO;
+                this.checkGLError("fsaa " + eye);
+                this.profiler.pop();
+            }
+
+            if (this.currentPass == RenderPass.LEFT)
+            {
+                this.vrRenderer.framebufferEye0.bindWrite(true);
+            }
+            else
+            {
+                this.vrRenderer.framebufferEye1.bindWrite(true);
+            }
+
+            if (this.vrSettings.useFOVReduction && this.vrPlayer.getFreeMove())
+            {
+                if (this.player != null && (Math.abs(this.player.zza) > 0.0F || Math.abs(this.player.xxa) > 0.0F))
+                {
+                    this.fov = (float)((double)this.fov - 0.05D);
+
+                    if (this.fov < this.vrSettings.fovReductionMin)
+                    {
+                        this.fov = this.vrSettings.fovReductionMin;
+                    }
+                }
+                else
+                {
+                    this.fov = (float)((double)this.fov + 0.01D);
+
+                    if ((double)this.fov > 0.8D)
+                    {
+                        this.fov = 0.8F;
+                    }
+                }
+            }
+            else
+            {
+                this.fov = 1.0F;
+            }
+
+            GlStateManager._glUseProgram(VRShaders._FOVReduction_shaderProgramId);
+            ARBShaderObjects.glUniform1iARB(VRShaders._FOVReduction_TextureUniform, 0);
+            ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_OffsetUniform, this.vrSettings.fovRedutioncOffset);
+            float red = 0.0F;
+            float black = 0.0F;
+            float blue = 0.0F;
+            float time = (float)Util.getMillis() / 1000.0F;
+
+            if (this.player != null && this.level != null)
+            {
+                if (this.gameRenderer.wasinwater != this.gameRenderer.inwater)
+                {
+                    this.watereffect = 2.3F;
+                }
+                else
+                {
+                    if (this.gameRenderer.inwater)
+                    {
+                        this.watereffect -= 0.008333334F;
+                    }
+                    else
+                    {
+                        this.watereffect -= 0.016666668F;
+                    }
+
+                    if (this.watereffect < 0.0F)
+                    {
+                        this.watereffect = 0.0F;
+                    }
+                }
+
+                this.gameRenderer.wasinwater = this.gameRenderer.inwater;
+
+                if (Config.isShaders())
+                {
+                    this.watereffect = 0.0F;
+                }
+
+                if (this.gameRenderer.inportal)
+                {
+                    this.portaleffect = 1.0F;
+                }
+                else
+                {
+                    this.portaleffect -= 0.016666668F;
+
+                    if (this.portaleffect < 0.0F)
+                    {
+                        this.portaleffect = 0.0F;
+                    }
+                }
+
+                ItemStack itemstack = this.player.getInventory().getArmor(3);
+
+                if (itemstack.getItem() == Blocks.CARVED_PUMPKIN.asItem() && (!itemstack.hasTag() || itemstack.getTag().getInt("CustomModelData") == 0))
+                {
+                    this.pumpkineffect = 1.0F;
+                }
+
+                float hurtTimer = (float)this.player.hurtTime - nano;
+                float healthpercent = 1.0F - this.player.getHealth() / this.player.getMaxHealth();
+                healthpercent = (healthpercent - 0.5F) * 0.75F;
+
+                if (hurtTimer > 0.0F)
+                { //hurt flash
+                    hurtTimer = hurtTimer / (float)this.player.hurtDuration;
+                    hurtTimer = healthpercent + Mth.sin(hurtTimer * hurtTimer * hurtTimer * hurtTimer * (float)Math.PI) * 0.5F;
+                    red = hurtTimer;
+                }
+                else
+                { //red due to low health
+                    red = (float)((double)healthpercent * Math.abs(Math.sin((double)(2.5F * time) / ((double)(1.0F - healthpercent) + 0.1D))));
+
+                    if (this.player.isCreative())
+                    {
+                        red = 0.0F;
+                    }
+                }
+
+                float freeze = this.player.getPercentFrozen();
+                if(freeze > 0 ){
+                	blue = red;
+                	blue = Math.max(freeze / 2, blue);
+                	red = 0;
+                }
+                
+                
+                if (this.player.isSleeping() && (double)black < 0.8D)
+                {
+                    black = 0.8F;
+                }
+
+                if (this.vr.isWalkingAbout && (double)black < 0.8D)
+                {
+                    black = 0.5F;
+                }
+            }
+            else
+            {
+                this.watereffect = 0.0F;
+                this.portaleffect = 0.0F;
+                this.pumpkineffect = 0.0F;
+            }
+
+            if (this.pumpkineffect > 0.0F)
+            {
+                ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_RadiusUniform, 0.3F);
+                ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_BorderUniform, 0.0F);
+            }
+            else
+            {
+                ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_RadiusUniform, this.fov);
+                ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_BorderUniform, 0.06F);
+            }
+
+            ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_HealthAlpha, red);
+            ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_FreezeAlpha, blue);
+            ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_BlackAlpha, black);
+            ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_time, time);
+            ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_waterAmplitude, this.watereffect);
+            ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_portalAmplitutde, this.portaleffect);
+            ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_pumpkinAmplitutde, this.pumpkineffect);
+            RenderPass renderpass = this.currentPass;
+            ARBShaderObjects.glUniform1iARB(VRShaders._Overlay_eye, this.currentPass == RenderPass.LEFT ? 1 : -1);
+            rendertarget.blitLegacy = true;
+            rendertarget.blitToScreen(this.vrRenderer.framebufferEye0.viewWidth, this.vrRenderer.framebufferEye0.viewHeight);
+            rendertarget.blitLegacy = false;
+            GlStateManager._glUseProgram(0);
+            this.checkGLError("post overlay" + eye);
+            this.profiler.pop();
+        }
+
+        if (this.currentPass == RenderPass.CAMERA)
+        {
+            this.profiler.push("cameracopy");
+            this.vrRenderer.cameraFramebuffer.bindWrite(true);
+            GlStateManager._clearColor(0.0F, 0.0F, 0.0F, 1.0F);
+            GlStateManager.clear(16640);
+            this.vrRenderer.cameraRenderFramebuffer.blitToScreen(0, this.vrRenderer.cameraFramebuffer.viewWidth, this.vrRenderer.cameraFramebuffer.viewHeight, 0, true, 0.0F, 0.0F, false);
+            this.profiler.pop();
+        }
+    }
+
+    //Forge
+    public ItemColors getItemColors()
+    {
+        return this.itemColors;
+    }
+
+    public SearchRegistry getSearchTreeManager()
+    {
+        return this.searchRegistry;
+    }
+    //
+    
+    public void loadClassPath()
+    {
+        File file1 = new File("../src/resources");
+
+        if (file1.exists() && file1.isDirectory())
+        {
+            Method method = null;
+
+            try
+            {
+                method = URLClassLoader.class.getDeclaredMethod("addURL", URL.class);
+                method.setAccessible(true);
+                method.invoke(ClassLoader.getSystemClassLoader(), file1.toURI().toURL());
+            }
+            catch (Exception exception)
+            {
+                exception.printStackTrace();
+            }
+        }
+    }
+
+    public void notifyMirror(String text, boolean clear, int lengthMs)
+    {
+        this.mirroNotifyStart = System.currentTimeMillis();
+        this.mirroNotifyLen = (long)lengthMs;
+        this.mirrorNotifyText = text;
+        this.mirrorNotifyClear = clear;
+    }
+
+    public void drawNotifyMirror()
+    {
+        if (System.currentTimeMillis() < this.mirroNotifyStart + this.mirroNotifyLen)
+        {
+            RenderSystem.viewport(0, 0, this.window.getScreenWidth(), this.window.getScreenHeight());
+            Matrix4f matrix4f = Matrix4f.orthographic(0.0F, (float)this.window.getScreenWidth(), 0.0F, (float)this.window.getScreenHeight(), 1000.0F, 3000.0F);
+            RenderSystem.setProjectionMatrix(matrix4f);
+            RenderSystem.getModelViewStack().setIdentity();
+            RenderSystem.getModelViewStack().translate(0, 0, -2000);
+            RenderSystem.applyModelViewMatrix();
+            PoseStack p = new PoseStack();
+            p.scale(3, 3, 3);
+            RenderSystem.clear(256, ON_OSX);
+            
+            if (this.mirrorNotifyClear)
+            {
+                RenderSystem.clearColor(0,0,0,0);
+                RenderSystem.clear(16384, ON_OSX);
+            }
+
+            int i = this.window.getScreenWidth() / 22;
+            ArrayList<String> arraylist = new ArrayList<>();
+
+            if (this.mirrorNotifyText != null)
+            {
+                Utils.wordWrap(this.mirrorNotifyText, i, arraylist);
+            }
+
+            int j = 1;
+            int k = 12;
+
+            for (String s : arraylist)
+            {
+                this.font.draw(p, s, 1.0F, (float)j, 16777215);
+                j += 12;
+            }
+        }
+    }
+
+    static enum ExperimentalDialogType
+    {
+        NONE,
+        CREATE,
+        BACKUP;
+    }
+    // FORGE START
+    private float realPartialTick;
+    public float getPartialTick() {
+       return realPartialTick;
+    }
+    // FORGE END
 }
